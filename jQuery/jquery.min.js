/ *! jQuery v3.4.1 | c) Fondation JS et autres contributeurs | jquery.org/license * /
! function (e, t) {"use strict"; "objet" == typeof module && "objet" == typeof module.exports? module.exports = e.document? t (e,! 0): fonction (e) {if (! e.document) renvoie une nouvelle erreur ("jQuery nécessite une fenêtre avec un document"); renvoie t (e)}: t (e)} ("undefined"! = typeof window? window: this (function) C, e) {"utiliser strict"; var t = [], E = Document C., r = Objet.getPrototypeOf, s = t.slice, g = t.concat, u = t.push, i = t. indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call (Objet), y = {}, m = fonction (e) {retour "fonction" == typeof e && "numéro"! = type e.nodeType}, x = fonction (e) {retourne null! = e && e === e.window}, c = {type:! 0, src:! 0, nonce: ! 0, noModule:! 0}; fonction b (e, t, n) {varr, i, o = (n = n || E) .createElement ("script"); if (o.text = e, t) pour (r dans c) (i = t [r] || t.getAttribute && t.getAttribute (r)) && o.setAttribute (r, i); n.head.appendChild (o) .parentNode.removeChild (o)} fonction w (e) {retour null == e? e + "": "objet" = = typeof e || "fonction" == typeof e? n [o.call (e)] || "objet": typeof e} var f = "3.4.1", k = fonction (e, t) {retour nouveau k.fn.init (e, t)}, p = / ^ [\ s \ uFFE \ xA0] + | [\ s \ uFFE \ xA0] + $ / g; fonction d (e) {var t =! ! e && "longueur" dans e && e.longueur, n = w (e); retourne! m (e) &&! x (e) && ("tableau" === n || 0 === t || "nombre" == typeof t && 0 <t && t-1 dans e)} k.fn = k.prototype = {jquery: f, constructeur: k, longueur: 0, toArray: function () {return s.call (this)}, get: function (e) {return null == e? s.call (this): e <0? this [e + this.length]: this [e]}, pushStack: function (e) {var t = k.merge (this.constructor (), e); retourne t.prevObject = ceci, t}, chacun: fonction (e) {retourne k.each (ceci, e)}, map:function (n) {retour this.pushStack (k.map (this, fonction (e, t) {return n.call (e, t, e)}))}, slice: function () {retour this.pushStack ( s.apply (this, arguments))}, première: fonction () {retourne this.eq (0)}, dernière: fonction () {retourne cette.eq (-1)}, eq: fonction (e) {var t = this.length, n = + e + (e <0? t: 0); renvoie this.pushStack (0 <= n && n <t? [this [n]]: [])}, end: function () { Renvoie this.prevObject || this.constructor ()}, appuyez sur: u, sort: t.sort, splice: t.splice}, k.extend = k.fn.extend = function () {var e, t, n , r, i, o, a = arguments [0] || {}, s = 1, u = arguments.length, l =! 1; pour ("booléen" == typede a && (l = a, a = arguments [s] || {}, s ++), "objet" == type de a || m (a) || (a = {}), s === u && (a = ceci, s -); s < u; s ++) if (null! = (e = arguments [s])) pour (t dans e) r = e [t], "__ proto __"! == t && a! == r && (l && r && (k.isPlainObject (r ) || (i = Array.isArray (r)))? (n = a [t], o = i &&!Array.isArray (n)? []: I || k.isPlainObject (n)? N: {}, i =! 1, a [t] = k.extend (l, o, r)): vide 0! == r && (a [t] = r)); renvoyer a}, k.extend ({expando: "jQuery" + (f + Math.random ()). replace (/ \ D / g, ""), isReady:! 0, erreur: fonction (e) {lance une nouvelle erreur (e)}, noop: fonction () {}, isPlainObject: fonction (e) {var t, n; retourne! (! e || "[objet Objet] "! == o.call (e)) && (! (T = r (e)) ||" fonction "== typeof (n = v.call (t," constructeur ") && t.constructor) && a .call (n) === l)}, isEmptyObject: function (e) {var t; pour (t dans e), retournez! 1; return! 0}, globalEval: fonction (e, t) {b (e, {nonce: t && t.nonce})}, chaque: fonction (e, t) {var n, r = 0; si (d (e)) {pour (n = e.longueur; r <n; r ++) si ( ! 1 === t.call (e [r], r, e [r])) pause} else pour (r dans e) if (! 1 === t.call (e [r], r, e [r])) break; retour e}, trim: fonction (e) {retour null == e? "" :( e + ""). replace (p, "")},makeArray: fonction (e, t) {var n = t || []; retourne null! = e && (d (Object (e))? k.merge (n, "chaîne" == typede e? [e]: e): u.call (n, e)), n}, inArray: fonction (e, t, n) {retour null == t? -1: i.call (t, e, n)}, fusionner: fonction (e, t) {pour (var n = + longueur t, r = 0, i = longueur e; r <n; r ++) e [i ++] = t [r]; retour e. longueur = i, e}, grep: fonction (e, t, n) {pour (var r = [], i = 0, o = e.longueur, a =! n; i <o; i ++)! t (e [i] , i)! == a && r.push (e [i]); retourne r}, map: fonction (e, t, n) {varr, i, o = 0, a = []; si (d (e )) pour (r = e.length; o <r; o ++) null! = (i = t (e [o], o, n)) && a.push (i); sinon pour (o dans e) null! = (i = t (e [o], o, n)) && a.push (i); retourne g.apply ([], a)}, guid: 1, support: y}), "fonction" == typeof Symbol && (k.fn [Symbol.iterator] = t [Symbol.iterator]), k.each ("Valeur booléenne Chaîne de fonctions Matrice Date RegExp Symbole d'erreur d'objet" .split (""), fonction (e, t) { n ["[objet" + t + "] "] = t.toLowerCase ()}); var h = fonction (n) {var, d, b, o, i, h, f, g, w, u, l, T, C, a, E , v, s, c, y, k = "grésillement" + 1 * nouvelle date, m = document n, S = 0, r = 0, p = ue (), x = ue (), N = ue ( ), A = ue (), D = fonction (e, t) {retour e === t && (l =! 0), 0}, j = {}. HasOwnProperty, t = [], q = t.pop , L = t.push, H = t.push, O = t.slice, P = fonction (e, t) {pour (var n = 0, r = e.longueur; n <r; n ++) si (e [n] === t) retourne n; retourne-1}, R = "coché | sélectionné | asynchrone | autofocus | lecture automatique | contrôles | différer | désactivé | caché | ismap | boucle | multiple | ouvert | lu seulement | requis | scoped ", M =" [\\ x20 \\ t \\ r \\ n \\ f] ", I =" (?: \\\\. | [\\ w-] | [^ \ 0 - \\ xa0]) + ", W =" \\ ["+ M +" * ("+ I +") (?: "+ M +" * ([* ^ $ |! ~]? =) "+ M +" * (? : '((?: \\\\. | [^ \\\\' ')) *)' | \ "((?: \\\\. | [^ \\\\\"]) *) \ "| (" + I + ")) |)" + M + "* \\]", $ = ":(" + I + ") (?: \\ (('((?: \\\\. | [^ \\\\ ']) *)'| \ "((?: \\\\. | [^ \\\\\"]) *) \ ") | ((?: \\\\. | [^ \\\\ () [\\ ]] | "+ W +") *) |. *) \\) |) ", F = nouvelle RegExp (M +" + "," g "), B = nouvelle RegExp (" ^ "+ M +" + | ( (?: ^ | [^ \\\\]) (?: \\\\.) *) "+ M +" + $ "," g "), _ = nouvelle RegExp (" ^ "+ M +" *, "+ M +" * "), z = nouvelle RegExp (" ^ "+ M +" * ([> + ~] | "+ M +") "+ M +" * "), U = nouvelle RegExp (M +" |> " ), X = nouvelle RegExp ($), V = nouvelle RegExp ("^" + I + "$"), G = {ID: nouvelle RegExp ("^ # (" + I + ")"), CLASSE: nouvelle RegExp ( "^ \\. (" + I + ")"), TAG: nouvelle RegExp ("^ (" + I + "| [*])"), ATTR: nouvelle RegExp ("^" + W), PSEUDO: nouvelle RegExp ("^" + $), CHILD: new RegExp ("^ :( seulement | premier | dernier | dernier | nième-dernier) - (enfant | de type) (?: \\ (" + M + "* (même | impair | (([+ -] |) (\\ d *) n |) "+ M +" * (?:([+ -] |) "+ M +" * (\\ d +) |)) "+ M +" * \\) |) "," i "), bool: new RegExp (" ^ (?: "+ R + ") $", "i"), needsContext: new RegExp ("^" + M + "* [> + ~] |: (pair | impair | eq | gt | lt | nt | premier | dernier) (?: \ \ ("+ M +" * ((?: - \\ d)? \\ d *) "+ M +" * \\) |) (? = [^ -] | $) "," i ")}, Y = / HTML $ / i, Q = / ^ (?: input | select | textarea | button) $ / i, J = / ^ h \ d $ / i, K = / ^ [^ {] + \ {\ s * \ [natif \ w /, Z = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, ee = / [+ ~] /, te = new RegExp ("\\\\ ([\\ da-f] {1,6}" + M + "? | (" + M + ") |.)", "ig"), ne = fonction (e, t, n) {var r = "0x" + t-65536; retourne r! = r || n? t: r <0? String.fromCharCode (r + 65536): String.fromCharCode (r >> 10 | 55296,1023 & r | 56320)}, re = / ([\ 0- \ x1f \ x7f] | ^ -? \ D) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g, ie = fonction (e, t) {retourne t? "\ 0" === e? "\ ufffd": e.slice (0, -1) + "\\ "+ e.charCodeAt (e.length-1) .toString (16) +" ":" \\ "+ e}, oe = fonction () {T ()}, ae = be (fonction (e) {return! 0 === e.disabled && "fieldset" === e.nodeName.toLowerCase ()}, {dir: "parentNode", ensuite: "legend"}); essayez {H.apply (t = O. appel (m.childNodes), m.childNodes), t [m.childNodes.length] .nodeType} catch (e) {H = {appliquer: t.length? fonction (e, t) {L.apply (e, O.call (t))}: fonction (e, t) {var n = longueur e, r = 0; tandis que (e [n ++] = t [r ++]); e. longueur = n-1}}} fonction se (t, e, n, r) {var i, o, a, s, u, l, c, f = e & document propriétaire, p = e? e.nodeType: 9; si (n = n || [], "string"! = typeof t ||! t || 1! == p && 9! == p && 11! == p) retourne n; si (! r && ((e? e.ownerDocument || e: m) ! == C && T (e), e = e || C, E)) {if (11! == p && (u = Z.exec (t))) if (i = u [1]) {if (9 === p) {if (! (a = e.getElementById (i))) renvoie n; if (a.id === i) renvoie n.push (a), n} sinon si (f && (a = F.getElementById (i)) && y (e, a) && a.id === i) renvoie n.push (a), n} autre {si (u [2]) renvoie H.apply (n, e.getElementsByTagName (t )), n; si ((i = u [3]) && d.getElementsByClassName && e.getElementsByClassName) renvoie H.apply (n, e.getElementsByClassName (i)), n} if (d.qsa &&! A [t + ""] && (! v ||! v.test (t)) && (1! == p || "objet"! == e.nodeName.toLowerCase ())) {if (c = t, f = e, 1 === p && U.test (t)) {(s = e.getAttribute ("id"))? s = s.replace (re, ie): e.setAttribute ("id", s = k), o = (l = h (t)). length; tandis que (o -) l [o] = "#" + s + "" + xe (l [o]); c = l.join (","), f = ee.test (t) && ye (e.parentNode) || e} try {return H.apply (n, f.querySelectorAll (c)), n} catch (e) {A (t,! 0)} enfin {s === k && e.removeAttribute ("id")}}} return g (t.replace (B, "$ 1"), e, n, r)} function ue () {var r = [];retourne la fonction e (t, n) {retourne r.push (t + "")> b.cacheLength && supprime e [r.shift ()], e [t + ""] = n}} fonction le (e) {retour e [ k] =! 0, e} function ce (e) {var t = C.createElement ("fieldset"); essayer {return !! e (t)} catch (e) {return! 1} finally {t.parentNode && t .parentNode.removeChild (t), t = null}} fonction fe (e, t) {var n = e.split ("|"), r = longueur n; tant que (r -) b.attrHandle [n [r]] = t} fonction pe (e, t) {var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex-t.sourceIndex; if (r) renvoie r; si (n) while (n = n.nextSibling) if (n === t) renvoie-1; retourne e? 1: -1} fonction de (t) {retourne fonction (e) {retourne "entrée" === e.nodeName.toLowerCase () && e.type === t}} fonction he (n) {return fonction (e) {var t = e.nodeName.toLowerCase (); return ("entrée" === t || "bouton" === t) && e.type === n}} function ge (t) {return fonction (e) {return "formulaire" dans e? e.parentNode &&! 1 === e.disabled? "label" dans e? "label" dans e. parentNode? e.parentNode.disabled === t: e.disabled === t: e.isDisabled === t || e.isDisabled! ==! t && ae (e) === t: e.disabled == = t: "label" dans e && e.disabled === t}} fonction ve (a) {retourne le (fonction (o) {retourne o = + o, le (fonction (e, t) {var n, r = a ([], e.longueur, o), i = r.longueur; tandis que (i -) e [n = r [i]] && (e [n] =! (t [n] = e [n ]))})})} function ye (e) {return e && "undefined"! = typeof e.getElementsByTagName && e} pour (e dans d = se.support = {}, i = se.isXML = fonction (e) { var t = e.namespaceURI, n = (e.ownerDocument || e) .documentElement; return! Y.test (t || n && n.nodeName || "HTML")}, T = se.setDocument = function (e) {var t, n, r = e? e.ownerDocument || e: m; return r! == C && 9 === r.nodeType && r.documentElement && (a = (C = r) .documentElement, E =! i (C), m! == C && (n = C.defaultView) && n.top! == n && (n.addEventListener? n.addEventListener ("unload ", oe,! 1): n.attachEvent && n.attachEvent (" onunload ", oe)), d.attributes = ce (fonction (e) {return e.className =" i ",! e.getAttribute (" className " )}), d.getElementsByTagName = ce (fonction (e) {retourne e.appendChild (C.createComment ("")),! e. getElementsByTagName ("*"). length}), d.getElementsByClassName = K.test (C.getElementsByClassName), d.getById = ce (fonction (e) {retour a.appendChild (e) .id = k,! C.getElementsByName ||! C.getElementsByName (k) .length}), d.getById ? (b.filter.ID = function (e) {var t = e.replace (te, ne); return function (e) {return e.getAttribute ("id") === t}}, b.find .ID = fonction (e, t) {if ("indéfini"!! = Typeof t.getElementById &&E) {var n = t.getElementById (e); retourne n? [N]: []}}) :( b.filter.ID = fonction (e) {var n = e.replace (te, ne); fonction de retour (e) {var t = "indéfini"! = type de e.getAttributeNode && e.getAttributeNode ("id"); retourne t && t.valeur === n}}, b.find.ID = fonction (e, t) { if ("undefined"! = type of t.getElementById && E) {var n, r, i, o = t.getElementById (e); if (o) {if ((n = o.getAttributeNode ("id")) && n. valeur === e) retourne [o]; i = t.getElementsByName (e), r = 0; tant que (o = i [r ++]) if ((n = o.getAttributeNode ("id")) && n.value === e) renvoyer [o]} renvoyer []}}), b.find.TAG = d.getElementsByTagName? fonction (e, t) {retour "indéfini"! = type de t.getElementsByTagName? t.getElementsByTagName (e ): d.qsa? t.querySelectorAll (e): void 0}: fonction (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {while (n = o [i ++]) 1 === n.nodeType &&r.push (n); return r} return o}, b.find.CLASS = d.getElementsByClassName && fonction (e, t) {if ("indéfini"!! = typeof t.getElementsByClassName && E) return t.getElementsByClassName (e)}, s = [], v = [], (d.qsa = K.test (C.querySelectorAll)) && (ce (fonction (e) {a.appendChild (e) .innerHTML = "<a id = '" + k + "'> </a> <select id ='" + k + "- \ r \\ 'msallowcapture =' '> <option sélectionnée =' '> </ option> </ select>", e.querySelectorAll (" [msallowcapture ^ = ''] ") length && v.push (" [* ^ $] = "+ M +" * (?: '' | \ "\") "), e.querySelectorAll (" [sélectionné] ") .length || v.push ("\\ [" + M + "* (?: valeur |" + R + ")"), e.querySelectorAll ("[id ~ =" + k + "-]"). length | | v.push ("~ ="), e.querySelectorAll (": vérifié"). length || v.push (": vérifié"), e.querySelectorAll ("a #" + k + "+ *"). length || v.push (". #. +. + + ~] ")}), ce (fonction (e) {e.innerHTML =" <a href='' disabled='disabled'> </a> <select disabled = 'disabled'> <option /> </ select > "; var t = C.createElement (" entrée "); t.setAttribute (" type "," caché "), e.appendChild (t) .setAttribute (" nom "," D "), e.querySelectorAll ( "[nom = d]"). length && v.push ("nom" + M + "* [* ^ $ |! ~]? ="), 2! == e.querySelectorAll (": activé"). length && v.push (": enabled", ": disabled"), a.appendChild (e) .disabled =! 0,2! == e.querySelectorAll (": désactivé"). length && v.push (": activé", ": désactivé "),e.querySelectorAll ("* ,: x"), v.push (",. *:")}), (d.matchesSelector = K.test (c = a.matches || a.webkitMatchesSelector || a. mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce (fonction (e) {d.disconnectedMatch = c.call (e, "*"), c.call (e, "[s! = '']: x "), s.push ("! = ", $)}), v = v.length && nouvelle RegExp (v.join (" | ")), s = s.length && nouvelle RegExp (s.join (" | ") ), t = K.test (a.compareDocumentPosition), y = t || K.test (a.contains)? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e , r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition )))}: fonction (e, t) {si (t) tant que (t = t.parentNode) si (t === e) retourne! 0; retourne! 1}, D = t? fonction (e, t ) {si (e === t) renvoie l =! 0,0; var n =! e.compareDocumentPosition-! t.compareDocumentPosition; retourne n || (1 & (n = (e.ownerDocument || e) === (t.ownerDocument || t)? e.compareDocumentPosition (t): 1) ||! d.sortDetached && t.compareDocumentPosition (e ) === n? e === C || e.ownerDocument === m && y (m, e)? - 1: t === C || t.ownerDocument === m && y (m, t)? 1 : u? P (u, e) -P (u, t): 0: 4 & n? -1: 1)}: fonction (e, t) {si (e === t) retourne l =! 0,0 ; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; si (! i ||! o) retourne e === C? -1 : t === C? 1: i? -1: o? 1: u? P (u, e) -P (u, t): 0; si (i === o) retourne pe (e, t ); n = e; tandis que (n = n.parentNode) a.unshift (n); n = t; tandis que (n = n.parentNode) s.unshift (n); tandis que (a [r] === s [r]) r ++; retourne r? pe (a [r], s [r]): a [r] === m? -1: s [r] === m? 1: 0}), C }, se.matches = function (e, t) {retour se (e, null, null, t)}, se.matchesSelector = fonction (e, t) {if ((e.ownerDocument || e)! == C && T (e), d.matchesSelector && E &&! A [t + ""] && (! S ||! S.test (t)) && (! V ||! V.test (t))) essayer {var n = c.call (e, t); if (n || d.disconnectedMatch || e.document && 11! == e.document.nodeType) renvoie n} catch (e) { A (t,! 0)} return 0 <se (C, null, [e]). Length}, se.contains = function (e, t) {return (e.ownerDocument || e)! == C && T (e), y (e, t)}, se.attr = fonction (e, t) {(e.ownerDocument || e)! == C && T (e); var n = b.attrHandle [t.toLowerCase ()], r = n && j.call (b.attrHandle, t.toLowerCase ())? n (e, t,! E): vide 0; retourne vide 0! == r? r: d.attributes ||! E? E.getAttribute (t) :( r = e.getAttributeNode (t)) && r.specified? R.value: null}, se.escape = function (e) {return (e + ""). Replace (re, ie)}, se.error = function (e) {lance une nouvelle erreur ("Erreur de syntaxe, expression non reconnue:" + e)}, se.uniqueSort = fonction (e) {var t, n = [], r = 0 , i = 0; si (l =! d.detectDuplicates, u =! d.sortStable && e.slice (0), e.sort (D), l) {while (t = e [i ++]) t === e [i] && (r = n.push (i)); tandis que (r -) e.splice (n [r], 1)} renvoie u = null, e}, o = se.getText = fonction (e) {var t, n = "", r = 0, i = e.nodeType; if (i ) {if (1 === i || 9 === i || 11 === i) {if ("chaîne" == typede e.textContent) retourne e.textContent; pour (e = e.firstChild; e; e = e.nextSibling) n + = o (e)} sinon si (3 === i || 4 === i) renvoie e.nodeValue} else tant que (t = e [r ++]) n + = o ( t); retourne n}, (b = se.selectors = {cacheLength: 50, createPseudo: le, correspondance: G, attrHandle: {}, recherche: {}, relative: {">": {dir: "parentNode" , d'abord:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", d'abord:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: fonction (e) {retourne e [1] = e [1]. Remplace (te, ne), e [3] = (e [3] || e [4] || e [5] || "") .replace (te, ne), "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0,4)} , ENFANT: fonction (e) {retourne e [1] = e [1] .toLowerCase (), "nième "=== e [1] .slice (0,3)? (e [3] || se.error (e [0]), e [4] = + (e [4]? e [5] + (e [6] || 1): 2 * ("pair" === e [3] || "impair" === e [3])), e [5] = + (e [7] + e [8] || "impair" === e [3])): e [3] && se.error (e [0]), e}, PSEUDO: fonction (e) {variable, n =! e [6] && e [2]; return G.CHILD.test (e [0])? null: (e [3]? e [2] = e [4] || e [5] || "": n && X.test (n) && (t = h (n,! 0)) && (t = n.indexOf (")", n.length-t) -n.length) && (e [0] = e [ 0]. Slice (0, t), e [2] = n.slice (0, t)), e.slice (0,3))}}, filtre: {TAG: function (e) {var t = e.replace (te, ne) .toLowerCase (); return "*" === e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t }}, CLASSE: fonction (e) {var t = p [e + ""]; retourne t || (t = new RegExp ("(^ |" + M + ")" + e + "(" + M + "| $ ) ")) && p (e, fonction (e) {retourne t.test (" chaîne "== typeof e.className && e.className || "undefined"! = type of e.getAttribute && e.getAttribute ("class") || ")}), ATTR: function (n, r, i) {fonction de retour (e ) {var t = se.attr (e, n); retourne null == t? "! =" === r:! r || (t + = "", "=" === r? t == = i: "! =" === r? t! == i: "^ =" === r? i && 0 === t.indexOf (i): "* =" === r? i && - 1 <t.indexOf (i): "$ =" === r? i && t.slice (-i.length) === i: "~ =" === r? -1 <("" + t.replace (F, "") + "") .indexOf (i): "| =" === r && (t === i || t.slice (0, i.length + 1) === i + "- "))}}, ENFANT: fonction (h, e, t, g, v) {var y =" nième "! == h.slice (0,3), m =" dernier "! == h.slice (-4), x = "of-type" === e; retourne 1 === g && 0 === v? Fonction (e) {retour !! e.parentNode}: fonction (e, t, n) { var, i, o, a, s, u, l = y!== m? "nextSibling": "previousSibling", c = e.parentNode, f = x && e.nodeName.toLowerCase (), p =! n &&! x, d =! 1; si (c) {si (y) { while (l) {a = e; while (a = a [l]) if (x? a.NodeName.toLowerCase () === f: 1 === a.nodeType) renvoie! 1; u = l = "seulement" === h &&! u && "nextSibling"} return! 0} if (u = [m? c.firstChild: c.lastChild], m && p) {d = (s = (r = (i = (o = (a = c) [k] || (a [k] = {})) [a.uniqueID] || (o [a.uniqueID] = {})) [h] || []) [0] === S && [[]] && [2], a = s && c.childNodes [s]; tandis que (a = ++ s && a && a [l] || (d = s = 0) || u.pop ()) if (1 === a.nodeType && ++ d && a === e) {i [h] = [S, s, d]; pause}} sinon (p && (d = s = (r = (i = (o = (a = e) [k] || (a [k] = {})) [a.ID unique] || (o [a.uniqueID] = {})) [h] || []) [0 ] === S && [[1]),! 1 === d) tandis que (a = ++ s && a && a [l] || (d = s = 0) || u.pop ()) if ((x? A .nodeName.toLowerCase () === f: 1 === a.nodeType) &&++ d && (p && ((i = (o = a [k] || (a [k] = {}))) [a.uniqueID] || (o [a.uniqueID] = {})) [h] = [S, d]), a === e)) pause; retour (d- = v) === g || d% g == 0 && 0 <= d / g}}}, PSEUDO: fonction (e , o) {var t, a = b.pseudos [e] || b.setFilters [e.toLowerCase ()] || se.error ("pseudo non pris en charge:" + e); renvoie a [k]? a ( o): 1 <a.length? (t = [e, e, "", o], b.setFilters.hasOwnProperty (e.toLowerCase ())? le (fonction (e, t) {var n, r = a (e, o), i = longueur.lorsque (i -) e [n = P (e, r [i])] =! (t [n] = r [i])}): fonction (e) {retourne a (e, 0, t)}): a}}, pseudos: {pas: le (fonction (e) {varr = [], i = [], s = f (e.remplace (B, "$ 1")); retourne s [k]? Le (fonction (e, t, n, r) {var i, o = s (e, nul, r, []), a = e.longueur ; tandis que (a -) (i = o [a]) && (e [a] =! (t [a] = i))}): fonction (e, t, n) {retour r [0] = e, s (r, null, n, i), r [0] = null,! i.pop ()}}), a: le (fonction (t) {return fonction (e) {return 0 <se ( t, e) .length}}), contient: le (fonction (t) {retour t = t.replace (te,ne), fonction (e) {return-1 <(e.textContent || o (e)). indexOf (t)}}), lang: le (fonction (n) {return V.test (n || " ") || se.error (" lang non pris en charge: "+ n), n = n.remplacer (te, ne) .toLowerCase (), fonction (e) {var t; do {if (t = E? e. lang: e.getAttribute ("xml: lang") || e.getAttribute ("lang")) return (t = t.toLowerCase ()) === n || 0 === t.indexOf (n + "- ")} while ((e = e.parentNode) && 1 === e.nodeType); return! 1}}), target: function (e) {var t = n.location && n.location.hash; renvoyer t && t.slice (1) === e.id}, racine: fonction (e) {retourne e === a}, focus: fonction (e) {retourne e === C.activeElement && (! C.hasFocus || C. hasFocus ()) && !! (e.type || e.href || ~ e.tabIndex)}, activé: ge (! 1), désactivé: ge (! 0), coché: fonction (e) {var t = e.nodeName.toLowerCase (); renvoyer "entrée" === t && !! e.checked || "option" === t && !! e.selected}, sélectionné:function (e) {return e.parentNode && e.parentNode.selectedIndex,! 0 === e.selected}, vide: fonction (e) {pour (e = e.firstChild; e; e = e.nextSibling) si (e .nodeType <6) return! 1; return! 0}, parent: function (e) {return! b.pseudos.empty (e)}, en-tête: function (e) {return J.test (e.nodeName)} , entrée: fonction (e) {return Q.test (e.nodeName)}, bouton: fonction (e) {var t = e.nodeNome.toLowerCase (); retourne "entrée" === t && "bouton" == = e.type || "bouton" === t}, texte: fonction (e) {var t; retourne "entrée" === e.nodeName.toLowerCase () && "text" === e.type && ( null == (t = e.getAttribute ("type")) || "text" === t.toLowerCase ())}, premier: ve (fonction () {return [0]}), dernier: ve ( fonction (e, t) {retour [t-1]}), eq: ve (fonction (e, t, n) {retour [n <0? n + t: n]}), même: ve (fonction ( e, t) {pour (var n = 0; n <t; n + = 2) e.push (n); retour e}), impair: ve (fonction (e,t) {pour (var n = 1; n <t; n + = 2) e.push (n); retour e}), lt: ve (fonction (e, t, n) {pour (var r = n < 0? N + t: t <n? T: n; 0 <- - r;) e.push (r); retour e}), gt: ve (fonction (e, t, n) {pour (var r = n <0? n + t: n; ++ r <t;) e.push (r); renvoyer e})}}). pseudos.nth = b.pseudos.eq, {radio:! 0, case à cocher:! 0, fichier:! 0, mot de passe:! 0, image:! 0}) b.pseudos [e] = de (e); pour (e dans {submit:! 0, réinitialiser:! 0}) b .pseudos [e] = he (e); fonction me () {} fonction xe (e) {pour (var t = 0, n = e.longueur, r = ""; t <n; t ++) r + = e [t] .value; retourne} fonction be (s, e, t) {var u = e.dir, l = e.next, c = l || u, f = t && "parentNode" === c, p = r ++; retourne la première fonction? (e, t, n) {tant que (e = e [u]) if (1 === e.nodeType || f) retourne s (e, t, n); return! 1}: fonction (e, t, n) {var r, i, o, a = [S, p]; si (n) {tant que (e = e [u]) if ((1 === e.nodeType || f) && s (e, t, n)) retourne! 0} sinon tandis que (e = e [u]) if (1 === e.nodeType || f) if (i = (o = e [k] || (e [k] = {})) [e.uniqueID] || (o [e.uniqueID] = {}), l && l === e.nodeName.toLowerCase ()) e = e [u] || e; sinon {if ((r = i [c]) & r [0] === S && r [1] === p) renvoie a [2] = r [2]; if ((i [c] = a) [2] = s (e, t, n)) retourne! 0} retourne! 1}} fonction nous (i) {retourne 1 <i.length? fonction (e, t, n) {var r = longueur.long; tant que (r -) if (! i [r] (e, t, n)) renvoie! 1; retour! 0}: i [0] } fonction Te (e, t, n, r, i) {pour (var o, a = [], s = 0, u = longueur e, l = null! = t; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), l && t.push (s))); renvoie une fonction} Ce (d, h, g, v , y, e) {return v &&! v [k] && (v = Ce (v)), y &&! y [k] && (y = Ce (y, e)), le (fonction (e, t, n , r) {var i, o, a, s = [], u = [], l = t.longueur, c = e || fonction (e, t, n) {pour (var r = 0, i = t.length; r <i; r ++) se (e, t [r], n); retourne n} (h || "*", n.nodeType? [n]: n, []), f =! d ||! e && h? c: Te (c, s, d, n, r), p = g? y || (e? d: l || v)? []: t: f; if (g && g ( f, p, n, r), v) {i = Te (p, u), v (i, [], n, r), o = i.longueur; tandis que (o -) (a = i [ o]) && (p [u [o]] =!(f [u [o]] = a))} si (e) {si (y || d) {si (y) {i = [], o = longueur, tandis que (o -) (a = p [o]) && i.push (f [o] = a); y (nul, p = [], i, r)} o = p.longueur; tandis que (o -) (a = p [o ]) && - 1 <(i = y? P (e, a): s [o]) && (e [i] =! (T [i] = a))}} sinon p = Te (p == = t? p.splice (l, p.length): p), y? y (null, t, p, r): H.apply (t, p)})} fonction Ee (e) {pour (var i, t, n, r = longueur e, o = b.relative [e [0] .type], a = o || b.relative [""], s = o? 1: 0, u = be (fonction (e) {return e === i}, a,! 0), l = être (fonction (e) {return-1 <P (i, e)}, a,! 0), c = [ fonction (e, t, n) {var r =! o && (n || t! == w) || ((i = t) .nodeType? u (e, t, n): l (e, t, n)); retourne i = nul, r}]; s <r; s ++) si (t = b.relative [e [s] .type]) c = [être (nous (c), t)]; sinon {if ((t = b.filter [e [s] .type] .apply (null, e [s] .matches)) [k]) {pour (n = ++ s; n <r; n ++) if (b.relative [e [n] .type]) break; renvoie Ce (1 <s && we (c), 1 <s && xe (e.slice (0, s-1) .concat ({valeur: "" === e [s-2] .type? "*": ""})). Remplacer (B, "$ 1"), t, s <n && Ee (e.slice (s, n)), n <r && Ee (e = e.slice (n)), n <r && xe (e)) } c.push (t)} retourne nous (c)} retourne me.prototype = b.filters = b.pseudos, b.setFilters = nouveau moi, h = se.tokenize = fonction (e, t) {var n, r, i, o, a, s, u, l = x [e + ""]; si (l) retourne t? 0: l.slice (0); a = e, s = [], u = b. preFilter; while (a) {for (o in n &&! (r = _. exec (a)) || (r && (a = a.slice (r [0] .length) || a), s.push ( i = [])), n =! 1, (r = z.exec (a)) && (n = r.shift (), i.push ({valeur: n, type: r [0] .remplace ( B, "")}), a = a.slice (n.length)), b.filter)! (R = G [o] .exec (a)) || u [o] &&! (R = u [o] (r)) || (n = r.shift (), i.push ({valeur: n, type: o, correspond à: r}), a = a.slice (n.length)); if (! n) break} retourne t? a.length: a? se.error (e): x (e, s) .slice (0)}, f = se.compile = fonction (e, t) {var n , v, y, m, x, r, i = [], o = [], a = N [e + ""]; si (! a) {t || (t = h (e)), n = t.longueur; tandis que (n -) (a = Ee (t [n])) [k]? i.push (a): o.push (a); (a = N (e, (v = 0, m = 0 <(y = i) .longueur, x = 0 <v.longueur, r = fonction (e, t, n, r, i) {u, a, s, u = 0, l = "0", c = e && [], f = [], p = w, d = e || x && b.find. TAG ("*", i), h = S + = null == p? 1: Math.random () || .1, g = d.length; pour (i && (w = t === C || t || i); l! == g && null! = (o = d [l]); l ++) {si (x && o) {a = 0, t || o.ownerDocument === C || (T (o) , n =! E); tandis que (s = v [a ++]) si (s (o, t || C, n)) {r.push (o); pause} i && (S = h)} m && (( o =! s && o) && u -, e && c.push (o))} if (u + = l, m &&! == u) {a = 0; tandis que (s = y [a ++]) s (c, f, t , n); si (e) {si (0 <u) tandis que (l -) c [l] || f [l] || (f [l] = q.call (r)); f = Te (f)} H.apply (r, f), i &&! e && 0 <f.longueur && 1 <u + y.length && se.uniqueSort (r)} retourne i && (S = h, w = p), c}, m? le (r): r))). sélecteur = e} retourne a}, g = se.sélectionner = fonction (e, t, n, r) {var i, o, a, s, u, l = "fonction" == typede e && e, c =!r && h (e = sélecteur || e); if (n = n || [], 1 === c.length) {if (2 <(o = c [0] = c [0] .slice ( 0)). Length && "ID" === (a = o [0]). Type && 9 === t.nodeType && E && b.relative [o [1] .type]) {if (! (T = (b.find. ID (a.matches [0] .replace (te, ne), t) || []) [0])) renvoie n; l && (t = t.parentNode), e = e.slice (o.shift ( ) .valeur.longueur)} i = G.needsContext.test (e)? 0: 0.longueur; tandis que (i -) {si (a = o [i], b.relatif [s = a.type] ) pause; si ((u = b.find [s]) && (r = u (a.matches [0]. .replace (te, ne)), ee.test (o [0] .type) && ye (t. parentNode) || t))) {if (o.splice (i, 1),! (e = r.length && xe (o))) return H.apply (n, r), n; break}}} return ( l || f (e, c)) (r, t,! E, n,! t || ee.test (e) && ye (t.parentNode) || t), n}, d.sortStable = k. split (""). sort (D) .join ("") === k, d.detectDuplicates = !! l, T (), d.sortDetached = ce (fonction (e) {return 1 & e.compareDocumentPosition (C .createElement ("champset "))}), ce (fonction (e) {retourne e.innerHTML =" <a href='#'> </a> "," # "=== e.firstChild.getAttribute (" href ") }) || fe ("type | href | hauteur | largeur", fonction (e, t, n) {if (! n) retourne e.getAttribute (t, "type" === t.toLowerCase ()? 1 : 2)}), d.attributes && ce (fonction (e) {return e.innerHTML = "<input />", e.firstChild.setAttribute ("valeur", ""), "" === e.firstChild. getAttribute ("value")}) || fe ("value", fonction (e, t, n) {if (! n && "input" === e.nodeName.toLowerCase ()) renvoie e.defaultValue}), ce (fonction (e) {retour null == e.getAttribute ("désactivé")}) || fe (R, fonction (e, t, n) {var r; si (! n) retourne! 0 === e [t]? t.toLowerCase () :( r = e.getAttributeNode (t)) && r.spécified? r.value: null}), se} (C); k.find = h, k.expr = h .selectors, k.expr [":"] = k.expr.pseudos, k.uniqueSort = k.unique = h.uniqueSort, k.text = h.getText, k.isXMLDoc = h.isXML, k.contains = h.contient, k.escapeSelector = h .escape; var T = fonction (e, t, n) {var r = [], i = vide 0! == n; tandis que ((e = e [t]) && 9! == e.nodeType) if ( 1 === e.nodeType) {if (i && k (e) .is (n)) break; r.push (e)} renvoie r}, S = fonction (e, t) {pour (var n = [] ; e; e = e.nextSibling) 1 === e.nodeType && e! == t && n.push (e); retourne n}, N = k.expr.match.needsContext; fonction A (e, t) {retourne e .nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()} var D = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; fonction j (e, n, r) {retour m (n)? k.grep ( e, fonction (e, t) {return !! n.call (e, t, e)! == r}): n.nodeType? k.grep (e, fonction (e) {return e === n ! == r}): "string"! = typeof n? k.grep (e, fonction (e) {return-1 <i.call (n, e)! == r}): k.filter (n , e, r)} k.filter = fonction (e, t,n) {var r = t [0]; retourne n && (e = ": not (" + e + "") "), 1 === t.length && 1 === r.nodeType? k.find.matchesSelector (r, e)? [r]: []: k.find.matches (e, k.grep (t, fonction (e) {return 1 === e.nodeType}))}, k.fn.extend ({find : fonction (e) {var t, n, r = longueur.liste, i = ceci; if ("chaîne"! = typede e) retourne ceci.pushStack (k (e) .filter (fonction () {pour (t = 0; t <r; t ++) if (k.contains (i [t], this)) return! 0})); for (n = this.pushStack ([]), t = 0; t <r; t ++) k.find (e, i [t], n); retourne 1 <r? k.uniqueSort (n): n}, filtre: fonction (e) {retourne this.pushStack (j (this, e || [],! 1))}, pas: fonction (e) {retourne this.pushStack (j (this, e || [],! 0))}, est: fonction (e) {retourne !! j (this , "chaîne" == typede e && N.test (e)? k (e): e || [],! 1) .length}}); var q, L = / ^ (?: \ s * (<[ \ w \ W] +>) [^>] * | # ([\ w -] +)) $ /; (k.fn.init = fonction (e, t, n) {var r, i; if ( ! e) retourne ceci; si (n = n || q, "chaîne" == typeof e) {si (!(r = "<" === e [0] && ">" === e [e.length-1] && 3 <= e.length? [null, e, null]: L.exec (e)) ||! r [1] && t) retourne! t || t.jquery? (t || n) .find (e): ce.constructeur (t) .find (e); if (r [1]) { if (t = t instance de k? t [0]: t, k.merge (ceci, k.parseHTML (r [1], t && t.nodeType? t.ownerDocument || t: E,! 0)), D. test (r [1]) && k.isPlainObject (t)) pour (r in t) m (this [r])? this [r] (t [r]): this.attr (r, t [r]) ; return this} return (i = E.getElementById (r [2])) && (this [0] = i, this.length = 1), this} return e.nodeType? (this [0] = e, this .length = 1, this): m (e)? void 0! == n.ready? n.ready (e): e (k): k.makeArray (e, this)}). prototype = k.fn , q = k (E); var H = / ^ (?: parents | prev (?: jusqu'à | tous)) /, O = {enfants:! 0, contenu:! 0, suivant:! 0, prev :! 0}; fonction P (e, t) {while ((e = e [t]) && 1! == e.nodeType); retourne e} k.fn.extend ({a: fonction (e) {var t = k (e, this), n = t.length; retourne ceci.filter (function () {for (var e = 0; e <n; e ++) if (k.contient (this, t [e])) return! 0})}, le plus proche: function (e, t) {var n, r = 0, i = this.longueur, o = [], a = "chaîne"! = typede e && k (e); if (! N.test (e)) pour (; r <i; r ++) pour (n = this [r]; n && n! == t; n = n.parentNode) if (n.NodeType <11 && (a? -1 <a.index (n): 1 === n.nodeType && k.find. matchesSelector (n, e))) {o.push (n); break} retourne ceci.pushStack (1 <o.length? k.uniqueSort (o): o)}, index: fonction (e) {retour e? "chaîne" == type de e? i.call (k (e), this [0]): i.call (this, e.jquery? e [0]: e): this [0] && this [0]. parentNode? this.first (). prevAll (). length: -1}, ajouter: function (e, t) {retour this.pushStack (k.uniqueSort (k.merge (this.get (), k (e, t))))}, addBack: function (e) {retourne this.add (null == e? this.prevObject: this.prevObject.filter (e))}}), k.each ({parent: fonction ( e) {var t = e.parentNode; renvoyer t && 11! == t.nodeType? t:null}, parents: fonction (e) {retour T (e, "parentNode")}, parentsUntil: fonction (e, t, n) {retour T (e, "parentNode", n)}, suivant: fonction (e ) {return P (e, "nextSibling")}, prev: fonction (e) {return P (e, "previousSibling")}, nextAll: fonction (e) {return T (e, "nextSibling")}, prevAll : fonction (e) {retour T (e, "previousSibling")}, nextUntil: fonction (e, t, n) {return T (e, "nextSibling", n)}, prevUntil: fonction (e, t, n ) {return T (e, "previousSibling", n)}, frères et soeurs: fonction (e) {return S ((e.parentNode || {}). firstChild, e)}, enfants: fonction (e) {return S (e.firstChild)}, contenu: function (e) {retourne "undefined"! = typede e.contentDocument? e.contentDocument: (A (e, "modèle") && (e = e.content || e), k.merge ([], e.childNodes))}}, fonction (r, i) {k.fn [r] = fonction (e, t) {var n = k.map (this, i, e); retourne "jusqu'à"!== r.slice (-5) && (t = e), t && "chaîne" == typede t && (n = filtre de k (t, n)), 1 <this.length && (O [r] || k .uniqueSort (n), H.test (r) && n.reverse ()), this.pushStack (n)}}); var R = / [^ \ x20 \ t \ r \ n \ f] + / g; fonction M (e) {retour e} fonction I (e) {projection e} fonction W (e, t, n, r) {var i; essayer {e && m (i = e.promise)? i.call (e) .done (t) .fail (n): e && m (i = e.then)? i.call (e, t, n): t.apply (vide 0, [e] .slice (r))} attraper ( e) {n.apply (vide 0, [e])}} k.Callbacks = fonction (r) {var e, n; r = "chaîne" == typeder? (e = r, n = {}, k.each (e.match (R) || [], fonction (e, t) {n [t] =! 0}), n): k.extend ({}, r); var i, t, o, a, s = [], u = [], l = -1, c = fonction () {pour (a = a ||, une fois, o = i =! 0; u.longueur; l = - 1) {t = u.shift (); while (++ l <longueur s))! 1 === s [l] .apply (t [0], t [1]) && r.stopOnFalse && (l = s .length, t =! 1)} r.memory || (t =! 1), i =! 1, a && (s = t? []: "")}, f = {add: function () {return s && (t &&! i && (l = s.longueur-1, u.push (t)), fonction n (e) {k.each (e, fonction (e, t) {m (t)? r.unique && f. has (t) || s.push (t): t && t.length && "chaîne"! == w (t) && n (t)})} (arguments), t &&! i && c ()), this}, remove: fonction () {retourne k.each (arguments, fonction (e, t) {var n; tandis que (-1 <(n = k.inArray (t, s, n))) s.splice (n, 1), n <= l && l -}), this}, a: function (e) {return e? -1 <k.inArray (e, s): 0 <s.longueur}, vide: function () {return s && (s = []), cela}, désactiver: fonction () {retour a = u = [], s = t = "", ceci}, désactivé: fonction () {retour! s}, lock: fonction () {retour a = u = [], t || i || (s = t = ""), this}, verrouillé: function () {return !! a}, fireWith: function (e, t) {return a || (t = [e, (t = t || []). slice? t.slice (): t], u.push (t), i || c ()), this}, fire: function () {return f.fireWith (this, arguments), this}, déclenché: function () {return !! o}};return f}, k.extend ({Différé: fonction (e) {var o = [["notifier", "progression", k.Callbacks ("mémoire"), k.Callbacks ("mémoire"), 2], ["résoudre", "terminé", k.Callbacks ("une fois en mémoire"), k.Callbacks ("une fois en mémoire"), 0, "résolu"], ["rejeter", "échouer", k.Callbacks (" une fois mémoire "), k.Callbacks (" une fois mémoire "), 1," rejeté "], i =" en attente ", a = {état: fonction () {retour i}, toujours: fonction () {retour s .done (arguments) .fail (arguments), this}, "catch": function (e) {return a.then (null, e)}, pipe: function () {var i = arguments; renvoie k.Deferred ( fonction (r) {k.each (o, fonction (e, t) {var n = m (i [t [4]]) && i [t [4]]; s [t [1]] (fonction () {var e = n && n.apply (this, arguments); e && m (e.promise)? e.promise (). progress (r.notify) .done (r.resolve) .fail (r.rejeter): r [t [0] + "avec"] (ceci, n? [e]: arguments)})}, i = null}). promise ()}, puis: fonction (t, n, r ) {var u = 0; fonction l (i, o, a, s) {retour function () {var n = ceci, r = arguments, e = fonction () {var e, t; if (! (i < u)) {if ((e = a.apply (n, r)) === o.promise ()) jette un nouveau TypeError ("auto-résolution pouvant être utilisée"); t = e && ("objet" == typeof e || "fonction" == typede e) && puis, m (t)? s? t.call (e, l (u, o, M, s), l (u, o, I, s)): (u ++, t.call (e, l (u, o, m, s), l (u, o, i, s), l (u, o, m, o.notifyWith))) :( a! = = M && (n = vide 0, r = [e]), (s || o.resolveWith) (n, r))}}, t = s? E: function () {try {e ()} catch ( e) {k.Deferred.exceptionHook && k.Deferred.exceptionHook (e, t.stackTrace), u <= i + 1 && (a! == I && (n = vide 0, r = [e]), o.rejectWith (n , r))}}; i? t () :( k.Deferred.getStackHook && (t.stackTrace = k.Deferred.getStackHook ()), C.setTimeout (t))}} retourne k.Différé (fonction (e) {o [0] [3] .add (l (0, e, m (r)? R: M, e.notifyWith)), o [1] [3] .add (l ( 0, e, m (t)? T: M)), o [2] [3] .add (l (0, e, m (n)? N: I))}). Promise ()}, promesse : fonction (e) {retourne null! = e? k.extend (e, a): a}}, s = {}; retourne k.each (o, fonction (e, t) {var n = t [2 ], r = t [5]; a [t [1]] = n.add, r && n.add (fonction () {i = r}, o [3-e] [2] .disable, o [3- e] [3] .disable, o [0] [2] .lock, o [0] [3] .lock), n.add (t [3] .fire), s [t [0]] = fonction () {retourne s [t [0] + "avec"] (this === s? void 0: this, arguments), this}, s [t [0] + "avec"] = n.fireWith}) , une (des) solution (s), e && e.call (s, s), s}, lorsque: function (e) {var n = arguments.length, t = n, r = Tableau (t), i = s.call (arguments), o = k.Deferred (), a = fonction (t) {fonction de retour (e) {r [t] = ceci, i [t] = 1 <arguments.length? s.call (arguments): e, - n || o.resolveWith (r, i)}}; if (n <= 1 && (W (e, o.one (a (t)).. résoudre, o.reject,! n), " en attente "=== o.state () || m (i [t] && i [t].alors))) retourne o.then (); while (t -) W (i [t], a (t), o.reject); retourne o.promise ()}}); var $ = / ^ ( Eval | Internal | Range | Référence | Syntaxe | Type | URI) Erreur $ /; k.Deferred.exceptionHook = fonction (e, t) {C.console && C.console.warn && e && $. Test (e.name) && C.console. warn ("exception jQuery.Deferred:" + e.message, e.stack, t)}, k.readyException = fonction (e) {C.setTimeout (fonction () {throw e})}; var F = k. Deferred (); fonction B () {E.removeEventListener ("DOMContentLoaded", B), C.removeEventListener ("load", B), k.ready ()} k.fn.ready = fonction (e) {retour F .alors (e) ["catch"] (fonction (e) {k.readyException (e)}), this}, k.extend ({isReady:! 1, readyWait: 1, ready: function (e) {( ! 0 === e? - k.readyWait: k.isReady) || (k.isReady =! 0)! == e && 0 <- k.readyWait || F.resolveWith (E, [k])} }), k.ready.then = F.then, "complete" === E.readyState || "loading "! == E.readyState &&! E.documentElement.doScroll? C.setTimeout (k.ready) :( E.addEventListener (" DOMContentLoaded ", B), C.addEventListener (" load ", B)); var _ = fonction (e, t, n, r, i, o, a) {var s = 0, u = longueur e, l = null == n; si ("objet" === w (n)) pour (s dans i =! 0, n) _ (e, t, s, n [s],! 0, o, a); sinon si (void 0! == r && (i =! 0, m (r) || (a =! 0), l && (a? (t.call (e, r), t = null) :( l = t, t = fonction (e, t, n) {retourne l.call (k (e), n)})), t)) pour (; s <u; s ++) t (e [s], n, a? r: appel.cn (e [s], s, t (e [ s], n))); retourne i? e: l? t.call (e): u? t (e [0], n): o}, z = / ^ - ms - /, U = / - ([az]) / g; fonction X (e, t) {retourne t.toUpperCase ()} fonction V (e) {retour e.replace (z, "ms -"). remplace (U, X)} var G = fonction (e) {return 1 === e.nodeType || 9 === e.nodeType ||! + E.nodeType}; fonction Y () {this.expando = k.expando + Y.uid ++} Y.uid = 1, Y.prototype = {cache: fonction (e) {var t = e [this.expando]; renvoie t || (t = {}, G (e) && (e.nodeType? e [this.expando] = t: Object.defineProperty (e, this.expando, {valeur: t, configurable:! 0})), t}, définissez: fonction (e, t, n) {var r, i = this.cache (e); if ("chaîne" == typede t) i [V (t)] = n; sinon pour (r dans t) i [V (r)] = t [r]; return i}, get: function (e, t) {return void 0 === t? this.cache (e): e [this.expando] && e [this.expando] [V (t) ]}, accès: fonction (e, t, n) {return void 0 === t || t && "string" == typeof t && void 0 === n? this.get (e, t) :( this.set (e, t, n), vide 0! == n? n: t)}, supprimer: fonction (e, t) {var n, r = e [ceci.expando]; if (vide 0! == r ) {if (void 0! == t) {n = (t = Array.isArray (t)? t.map (V) :( t = V (t)) dans r? [t]: t.match ( R) || []). Length; while (n -) supprimer r [t [n]]} (void 0 === t || k.isEmptyObject (r)) && (e.nodeType? E [this .expando] = void 0: delete e [this.expando])}}, hasData: function (e) {var t = e [this.expando]; retourne void 0! == t &&! k.isEmptyObject (t)} }; var Q = nouveau Y, J = nouveau Y,K = / ^ (?: \ {[\ W \ W] * \} | \ [[\ w \ W] * \]) $ /, Z = / [AZ] / g; fonction ee (e, t, n) {var r, i; if (void 0 === n && 1 === e.nodeType) if (r = "data -" + t.replace (Z, "- $ &"). toLowerCase (), " string "== typeof (n = e.getAttribute (r))) {try {n =" true "=== (i = n) ||" false "! == i && (" null "=== i? null: i === + i + ""? + i: K.test (i)? JSON.parse (i): i)} prise (e) {} J.set (e, t, n)} sinon n = void 0; retourne n} k.extend ({hasData: fonction (e) {return J.hasData (e) || Q.hasData (e)}, données: fonction (e, t, n) {return J. accès (e, t, n)}, removeData: fonction (e, t) {J.remove (e, t)}, _données: fonction (e, t, n) {return Q.access (e, t, n )}, _ removeData: fonction (e, t) {Q.remove (e, t)}}), k.fn.extend ({donnée: fonction (n, e) {var t, r, i, o = ceci [0], a = o && o.attributes; if (void 0 === n) {if (this.length && (i = J.get (o), 1 === o.nodeType &&! Q.get (o, " hasDataAttrs "))) {t = a.length;While (t -) a [t] && 0 === (r = a [t] .name) .indexOf ("data -") && (r = V (r.slice (5)), ee (o, r, i [r])); Q.set (o, "hasDataAttrs",! 0)} return i} return "object" == typeof n? this.each () {J.set (this, n )}): _ (this (fonction (e) {var t; si (o && void 0 === e) renvoie null 0! == (t = J.get (o, n))? t: void 0! = = (t = ee (o, n))? t: vide 0; this.each (fonction () {J.set (this, n, e)})}, null, e, 1 <arguments.length, null ,! 0)}, removeData: function (e) {retourne this.each (function () {J.remove (this, e)})}}), k.extend ({queue: function (e, t, n ) {var r; si (e) renvoie t = (t || "fx") + "file d'attente", r = Q.get (e, t), n && (! r || Array.isArray (n)? r = Q.access (e, t, k.makeArray (n)): r.push (n)), r || []}, délai: fonction (e, t) {t = t || "fx"; var n = k.queue (e, t), r = n.longueur, i = n.shift (), o = k.queueHooks (e, t); "inprogress" === i && (i = n.shift (), r -), i && ("fx "=== t && n.unshift (" inprogress "), supprimez o.stop, i.call (e, function () {k.dequeue (e, t)}, o)),! r && o &&.empty.fire ( )}, _ queueHooks: fonction (e, t) {var n = t + "queueHooks"; renvoie Q.get (e, n) || Q.access (e, n, {vide: k.Callbacks ("une fois en mémoire" ) .add (function () {Q.remove (e, [t + "queue", n])}}}}}), k.fn.extend ({queue: fonction (t, n) {var e = 2; retourne "chaîne"! = Typede t && (n = t, t = "fx", e -), arguments.length <e? K.queue (this [0], t): void 0 === n ? this: this.each (function () {var e = k.queue (this, t, n); k._queueHooks (this, t), "fx" === t && "inprogress"! == e [0 ] && k.dequeue (this, t)})}, file d'attente: function (e) {retourne this.each (fonction () {k.dequeue (this, e)})}, clearQueue: fonction (e) {retourne this .queue (e || "fx", [])}, promesse: fonction (e, t) {var n, r = 1, i = k. différé (), o = ceci, a = ceci.longueur, s = fonction () {- r || i.resolveWith (o, [o])}; "chaîne"! = typede e && (t = e, e = vide 0), e = e || "fx "; tandis que (a -) (n = Q.get (o [a], e +" queueHooks ")) && n.empty && (r ++, n.empty.add (s)); retourne s (), i.promise (t)}}); var te = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. source, ne = new RegExp ("^ (?: ([+ -]) = |) (" + te + ") ([az%] *) $", "i"), re = ["Haut", "Droite", "Bas "," Gauche "], c'est-à-dire = E.documentElement, oe = fonction (e) {return k.contains (e.ownerDocument, e)}, ae = {composé:! 0}; ie.getRootNode && (oe = fonction ( e) {return k.contains (e.ownerDocument, e) || e.getRootNode (ae) === e.ownerDocument}); var se = function (e, t) {return "none" === (e = t || e) .style.display || "" === e.style.display && oe (e) && "aucun" === k.css (e, "display")}, ue = fonction (e, t, nr) {var i, o, a = {}; pour (o in t) a [o] = e.style [o], e.style [o] = t [o]; pour (o in i = n .apply (e, r || []), t) style e [o] = a [o]; retour i}; fonction le (e, t, n, r) {var i, o, a = 20 , s = r? function () {return r.cur ()}: function () {return k.css (e, t, "")}, u = s (), l = n && n [3] || ( k.cssNumber [t]? "": "px"), c = e.nodeType && (k.cssNumber [t] || "px"! == l && + u) && ne.exec (k.css (e, t )); if (c && c [3]! == l) {u / = 2, l = l || c [3], c = + u || 1; tandis que (a -) k.style (e, t, c + l), (1-o) * (1- (o = s () / u || .5)) <= 0 && (a = 0), c / = o; c * = 2, k .style (e, t, c + l), n = n || []} renvoie n && (c = + c || + u || 0, i = n [1]? c + (n [1] +1 ) * n [2]: + n [2], r && (r.unité = l, r.start = c, r.end = i)), i} var ce = {}; fonction fe (e, t) {pour (var n, r, i, o, a, s, u, l = [], c = 0, f = e.longueur; c <f; c ++) (r = e [c]). style && ( n = r.style.display, t? ("none" === n && (l [c] = Q.get (r, "display") || null, l [c] || (r.style.display = "")), "" === r.style.display && se (r) && (l [c] = (u = a = o = vide 0, a = (i = r). propriétaireDocument, s = i.nodeName, (u = ce [s]) || (o = a.body.appendChild (a.createElement (s)), u = k.css (o, "display"), o.parentNode.removeChild (o), "none" === u && (u = "bloc"), ce [s] = u)))): "none"! == n && (l [c] = "none", Q.set (r, "display", n))); pour (c = 0; c <f; c ++) null! = l [c] && (e [c] .style.display = l [c]); retourne e } k.fn.extend ({show: function () {return fe (this,! 0)}, masquer: function () {return fe (this)}, bascule: function (e) {return "boolean" == typeof e? e? this.show (): this.hide (): this.each (function () {se (this)? k (this) .show (): k (this) .hide ()})} }); var pe = / ^ (?: case à cocher | radio) $ / i, de = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) / i, il = / ^ $ | ^ module $ | \ / (?: java | ecma) script / i, ge = {option: [1, "<sélectionnez multiple = 'multiple'> "," </ select> "], thead: [1," <table> "," </ table> "], col: [2," <table> <colgroup> ", "</ colgroup> </ table>"], tr: [2, "<table> <tbody>", "</ tbody> </ table>"], td: [3, "<table> <tbody> <tr> "," </ tr> </ tbody> </ table> "], _ défaut: [0," "," "]}; fonction ve (e, t) {var n; retour n =" non défini "! = typeof e.getElementsByTagName? e.getElementsByTagName (t ||" * "):" undefined "! = typeof e.querySelectorAll? e.querySelectorAll (t ||" * "): [], void 0 === t || t && A (e, t)? k.merge ([e], n): n} fonction ye (e, t) {pour (var n = 0, r = e.longueur; n <r; n ++) Q.set (e [n], "globalEval",! T || Q.get (t [n], "globalEval"))}} ge.optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td; var me, xe, be = / <| & #? \ w +; /; fonction we (e, t, n, r, i) {pour (var o, a, s, u, l, c, f = t.createDocumentFragment (), p = [], d = 0, h = e.length; d <h; d ++) if ((o = e [d]) || 0 === o) if ("objet" === w (o)) k.merge (p, o.nodeType ? [o]: o); sinon si (be.test (o)) {a = a || f.appendChild (t.createElement ("div")), s = (de.exec (o) || [ "", ""]) [1] .toLowerCase (), u = ge [s] || ge._default, a.innerHTML = u [1] + k.htmlPrefilter (o) + u [2], c = u [0]; tandis que (c -) a = a.lastChild; k.merge (p, a.childNodes), (a = f.firstChild) .textContent = ""} autre p.push (t.createTextNode ( o)); f.textContent = "", d = 0; tandis que (o = p [d ++]) si (r && - 1 <k.inArray (o, r)) i && i.push (o); sinon si (l = oe (o), a = ve (f.appendChild (o), "script"), l && ye (a), n) {c = 0; tandis que (o = a [c ++]) il.test (o.type || "") && n.push (o)} return f} me = E.createDocumentFragment (). appendChild (E.createElement ("div")), (xe = E.createElement ("entrée")). setAttribute ("type", "radio" ), xe.setAttribute ("coché", "coché"), xe.setAttribute ("nom", "t"), me.appendChild (xe), y.checkClone = me.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, me.innerHTML = "<textarea> x </ textarea>", y.noCloneChecked =! Me.cloneNode (! 0) .lastChild.defaultValue; var Te = / ^ clé /, Ce = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ee=/&((.^**)(?:\.(.+)|)/;function ke () {return! 0} function Se () {return! 1} function Ne (e, t) {return e === function () {try {return E.activeElement} catch (e) {}} () == ("focus" === t)} fonction Ae ("objet" == typeof t) {pour (s dans "chaîne"!! = typeof n && ( r = r || n, n = vide 0),t) Ae (e, s, n, r, t [s], o); retourne e} if (null == r && null == i? (i = n, r = n = vide 0): null == i && ("chaîne" == typede n? (i = r, r = vide 0) :( i = r, r = n, n = nul 0)),! 1 === i) i = Se; sinon si ( ! i) retourne e; retourne 1 === o && (a = i, (i = fonction (e) {retourne k (). off (e), a.apply (ceci, arguments)}). guid = a. guid || (a.guid = k.guid ++)), e.each (fonction () {k.event.add (ceci, t, i, r, n)})} fonction De (e, i, o) {o? (Q.set (e, i,! 1), k.event.add (e, i, {espace de noms:! 1, gestionnaire: fonction (e) {var t, n, r = Q.get ( this, i); if (1 & e.isTrigger && this [i]) {if (r.length) (k.event.special [i] || {}). delegateType && e.stopPropagation (); else if (r = s.call (arguments), Q.set (this, i, r), t = o (this, i), ceci [i] (), r! == (n = Q.get (this, i)) || t ? Q.set (this, i,! 1): n = {}, r! == n) retourne e.stopImmediatePropagation (), e.preventDefault (), n.value} else r.length && (Q.set ( ceci, i, {valeur: k.event.trigger (k.extend (r [0], k.Event.prototype)), r.slice (1), this)}), e.stopImmediatePropagation ())}})): void 0 === Q.get (e, i) && k.event.add (e, i, ke)} k.event = {global: {}, ajouter: fonction (t, e, n, r, i) {var o, a, s, u, l, c, f, p, d, h, g, v = Q.get (t); if (v) {n.handler && (n = (o = n) .handler, i = o.selector), i && k.find.matchesSelector (c'est-à-dire i), n.guid || (n.guid = k.guid ++), (u = v.events) || (u = v.events = {}), (a = v.handle) || (a = v.handle = function (e) {retourne "indéfini "! = typeof k && k.event.triggered! == e.type? k.event.dispatch.apply (t, arguments): void 0}), l = (e = (e ||" "). match (R ) || [""]). length; tandis que (l -) d = g = (s = Ee.exec (e [l]) || []) [1], h = (s [2] | | ""). split ("."). sort (), d && (f = événement.spécial [d] || {}, d = (i? f.delegateType: f.bindType) || d, f = k.event.special [d] || {}, c = k.extend ({type: d, origType: g, données: r, gestionnaire: n, guid: n.guid, sélecteur: i, needsContext: i && k.expr.match.needsContext.test (i),espace de noms: h.join (".")}, o), (p = u [d]) || ((p = u [d] = []). delegateCount = 0, f.setup &&! 1! == f.setup.call (t, r, h, a) || t.addEventListener && t.addEventListener (d, a)), f.add && (f.add.call (t, c), c.handler.guid || (c.handler.guid = n.guid)), i? p.splice (p.delegateCount ++, 0, c): p.push (c), k.event.global [d] =! 0)}}, remove: fonction (e, t, n, r, i) {var o, a, s, u, l, c, f, p, d, h, g, v = Q.hasData (e) && Q.get ( e); si (v && (u = événements v)) {l = (t = (t || ""). match (R) || [""]). length; tant que (l -) if ( d = g = (s = Ee.exec (t [l]) || []) [1], h = (s [2] || ""). split ("."). sort (), d ) {f = k.event.special [d] || {}, p = u [d = (r? f.delegateType: f.bindType) || d] || [], s = s [2] && new RegExp ("(^ | \\.)" + H.join ("\\. (?:. * \\. |)") + "(\\. | $)"), A = o = p. longueur; tandis que (o -) c = p [o],! i && g! == c.origType || n && n.guid! == c.guid || s &&! s.test (c.espace de noms) || r && r! == c.selector && ("**"! == r ||! c.selector) || (p.splice (o, 1), c.selector && p.delegateCount -, f.remove && f .remove.call (e, c)); a &&! p.length && (f.teardown &&! 1! == f.teardown.call (e, h, v.handle) || k.removeEvent (e, d, v .handle), supprimez u [d])} else pour (d en u) k.event.remove (e, d + t [l], n, r,! 0); k.isEmptyObject (u) && Q.remove (e, "gérer les événements")}}, dispatch: fonction (e) {var t, n, r, i, o, a, s = k.event.fix (e), u = new Array (arguments.length ), l = (Q.get (this, "events") || {}) [s.type] || [], c = k.event.special [s.type] || {}; pour (u [0] = s, t = 1; t <arguments.length; t ++) u [t] = arguments [t]; if (s.delegateTarget = this,! C.preDispatch ||! 1! == c.preDispatch .call (this, s)) {a = k.event.handlers.call (this, s, l), t = 0; tant que ((i = a [t ++]) &&! s.isPropagationStopped ()) {s .currentTarget = i.elem, n = 0; tandis que ((o = i.gestionnaires [n ++]) &&! s.isImmediatePropagationStopped ()) s.rnamespace &&! 1! == o.namespace &&! s.rnamespace.test (o.namespace) || (s.handleObj = o, s.data = o. data, void 0! == (r = ((k.event.special [o.origType] || {}). handle || o.handler) .apply (i.elem, u)) &&! 1 == = (s.result = r) && (s.preventDefault (), s.stopPropagation ()))} renvoie c.postDispatch && c.postDispatch.call (this, s), s.result}}, gestionnaires: function (e, t) {var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType &&! ("click" === e.type && 1 <= e .button)) pour (; l! == this; l = l.parentNode || this) if (1 === l.nodeType && ("click"! == e.type ||! 0! == l. désactivé)) {pour (o = [], a = {}, n = 0; n <u; n ++) void 0 === a [i = (r = t [n]). sélecteur + ""] && ( a [i] = r.needsContext? -1 <k (i, ceci) .index (l): k.find (i, ceci, null, [l]). length), un [i] && o.push ( r); o.length && s.push ({elem: l, gestionnaires: o})} retourne l = ceci, u <t.length && s.push ({elem: l, gestionnaires: t.slice (u)}), s}, addProp: fonction (t, e) {Object.defineProperty (k.Event.prototype, t, {enumerable:! 0, configurable:! 0, get: m (e)? function () {if (this.originalEvent) renvoie e (this .originalEvent)}: function () {if (this.originalEvent) renvoie this.originalEvent [t]}, définissez: function (e) {Object.defineProperty (this, t, {enumerable:! 0, configurable:! 0, writeable:! 0, valeur: e})}}}}, correction: function (e) {return e [k.expando]? e: new k.Event (e)}, spécial: {load: {noBubble :! 0}, cliquez sur: {setup: function (e) {var t = this || e; return pe.test (t.type) && t.click && A (t, "input") && De (t, "click", ke) ,! 1}, trigger: function (e) {var t = this || e; renvoyer pe.test (t.type) && t.click && A (t, "entrée") && De (t, "clic"),! 0 }, _ défaut: function (e) {var t = e.target; return pe.test (t.type) && t.click && A (t, "entrée") && Q.get (t, "clic") || A (t, "a")}}, avant le chargement: {postDispatch: function (e) {void 0! == e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)}}}}, k.removeEvent = fonction (e, t, n) {e.removeEventListener && e.removeEventListener (t , n)}, k.Event = fonction (e, t) {if (! (cette instance de k.Event)) renvoie new k.Event (e, t); e && e.type? (this.originalEvent = e, this .type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented &&! 1 === e.returnValue? ke: Voir, ceci.target = e.target && 3 === e.target .nodeType? e.target.parentNode: e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget): this.type = e, t && k.extend (this, t), this.timeStamp = e && e .timeStamp || Date.now (), this [k.expando] =!0}, k.Event.prototype = {constructeur: k.Event, isDefaultPrevented: Se, isPropagationStopped: Se, isImmediatePropagationStopped: Se, isSimulated:! 1, preventDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = ke, e &&! this.isSimulated && e.preventDefault ()}, stopPropagation: function () {var e = this.originalEvent; this.isPropagationStopped = ke, e &&! this.isSimulated && e.stopPropagation ()}, stopImmediatePropagation: function () e = this.originalEvent; this.isImmediatePropagationStopped = ke, e &&! this.isSimulated && e.stopImmediatePropagation (), this.stopPropagagation ()}}, k.each ({altKey:! 0, bulles:! 0, annulable:! 0, modifiedTouches:! 0, ctrlKey:! 0, détail:! 0, eventPhase:! 0, metaKey: 0, pageX:! 0, pageY:! 0, shiftKey:! 0, vue:! 0, "char":! 0, code:! 0, charCode:! 0, clé:! 0, keyCode:! 0, bouton:! 0, boutons:! 0, clientX:! 0, clientY:! 0, offsetX:! 0,offsetY:! 0, pointeurId:! 0, pointeurType:! 0, screenX:! 0, screenY:! 0, targetTouches:! 0, toElement:! 0, touche:! 0, qui: function (e) {var t = e.button; return null == e.which && Te.test (e.type)? null! = e.charCode? e.charCode: e.keyCode:! e.which && void 0! == t && Ce.test (e.type) ? 1 & t? 1: 2 & t? 3: 4 & t? 2: 0: e.which}}, k.event.addProp), k.each ({focus: "focusin", flou: "focusout"}, fonction (e, t) {k.event.special [e] = {setup: function () {return De (this, e, Ne) ,! 1}, trigger: function () {return De (this, e) ,! 0} , delegateType: t}}), k.each ({mouseenter: "mouseover", mouseleave: "mouseout", pointeurenter: "pointerover", pointeurleave: "pointerout"}, fonction (e, i) {k.event.special [e] = {delegateType: i, bindType: i, handle: fonction (e) {var t, n = e.relatedTarget, r = e.handleObj; renvoyer n && (n === this || k.contains (this , n)) || (type.e = r.origType, t = r.handler.apply (this, arguments), e.type = i), t}}}), k.fn.extend ({on: function (e, t, n, r) {retour Ae (ceci, e, t, n, r)}, un: fonction (e, t, n, r) {retourne Ae (ceci, e, t, n, r, 1)}, off: fonction (e, t , n) {var r, i; if (e && e.preventDefault && e.handleObj) renvoie r = e.handleObj, k (e.delegateTarget) .off (r.namespace? r.origType + "." + r.namespace: r. origType, r.selector, r.handler), this; if ("object" == typeof e) {for (i in e) this.off (i, t, e [i]); renvoie this} return! 1 ! == t && "fonction"! = typede t || (n = t, t = vide 0),! 1 === n && (n = Se), this.each (fonction () {k.event.remove ( ceci, e, n, t)})}}); var je = / <(?! zone | br | col | incorporer | hr | img | entrée | lien | meta | param) (([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) [^>] *) \ /> / gi, qe = / <script | <style | <lien / i, Le = / vérifié \ s * (?: [^ =] | = \ s * .checked.) / i, He = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | - -)> \ s * $ / g; fonction Oe (e,t) {retourne A (e, "table") && A (11! == t.nodeType? t: t.firstChild, "tr") && k (e) .children ("tbody") [0] || e} fonction Pe (e) {retour e.type = (null! == e.getAttribute ("type")) + "/" + e.type, e} fonction Re (e) {return "true /" === (e.type || ""). slice (0,5)? e.type = e.type.slice (5): e.removeAttribute ("type"), e} fonction Me (e, t) {var n, r, i, o, a, s, u, l; if (1 === t.nodeType) {if (Q.hasData (e) && (o = Q.access (e), a = Q. set (t, o), l = o.events)) pour (i dans supprimer a.handle, a.events = {}, l) pour (n = 0, r = l [i] .length; n <r ; n ++) k.event.add (t, i, l [i] [n]); J.hasData (e) && (s = J.access (e), u = k.extend ({}, s) , J.set (t, u))}} fonction Ie (n, r, i, o) {r = g.apply ([], r); var e, t, a, s, u, l, c = 0, f = longueur n, p = f-1, d = r [0], h = m (d); (d)) retourne n.chaque (fonction (e) {var t = n.eq (e); h && (r [0] = d.call (this, e, t.html ())), Ie (t, r, i, o) }); if (f && (t = (e = we (r, n [0] .ownerDocument,! 1, n, o)). firstChild, 1 === e.childNodes.length && (e = t), t || o)) {pour (s = (a = k.map (ve (e, "script"), Pe)). length; c <f; c ++) u = e, c! == p && (u = k.clone (u,! 0,! 0), s && k.merge (a, ve (u, "script"))), i.call (n [c], u, c); si (s) pour ( l = a [longueur.a1] .ownerDocument, k.map (a, Re), c = 0; c <s; c ++) u = a [c], he.test (u.type || "" ) &&! Q.access (u, "globalEval") && k.contains (l, u) && (u.src && "module"! == (u.type || ""). ToLowerCase ()? K._evalUrl &&! u.noModule && k._evalUrl (u.src, {nonce: u.nonce || u.getAttribute ("nonce")}): b (u.textContent.replace (He, ""), u, l))} return n} fonction We (e, t, n) {pour (varr, i = t? k.filtre (t, e): e, o = 0; null! = (r = i [o]);o ++) n || 1! == r.nodeType || k.cleanData (ve (r)), r.parentNode && (n && oe (r) && ye (ve (r, "script")), r.parentNode.removeChild ( r)); retourne e} k.extend ({htmlPrefilter: fonction (e) {retourne e.replace (je, "<$ 1> </ $ 2>")}, clone: ​​fonction (e, t, n) {var r, i, o, a, s, u, l, c = e.cloneNode (! 0), f = oe (e); if (! (y.noCloneChecked || 1! = = e.nodeType && 11! == e.nodeType || k.isXMLDoc (e)) pour (a = ve (c), r = 0, i = (o = ve (e)). length; r <i; r ++) s = o [r ], u = a [r], vide 0, "input" === (l = u.nomNom.toLowerCase ()) && pe.test (s.type)? u.checked = s.checked: "input"! == l && "textarea"! == l || (u.defaultValue = s.defaultValue); si (t) si (n) pour (o = o || ve (e), a = a || ve (c ), r = 0, i = longueur.r; r <i; r ++) Me (o [r], a [r]); sinon Me (e, c); retourne 0 <(a = ve (c, " script ")). length && ye (a,! f && ve (e," script ")), c}, cleanData:fonction (e) {pour (var t, n, r, i = événement spécial, o = 0; vide 0! == (n = e [o]); o ++) if (G (n)) { if (t = n [Q.expando]) {if (t.events) pour (r dans t.events) i [r]? k.event.remove (n, r): k.removeEvent (n, r, t.handle); n [Q.expando] = void 0} n [J.expando] && (n [J.expando] = void 0)}}}), k.fn.extend ({detach: function (e ) {return We (this, e,! 0)}, supprimez: fonction (e) {return We (this, e)}, texte: function (e) {return _ (this, function (e) {return void 0 === e? k.text (this): this.empty (). each (fonction () {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || (this.textContent = e)})}, null, e, arguments.length)}, append: function () {return Ie (this, arguments, function (e) {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || Oe (this, e) .appendChild (e)}), prepend: function () {return Ie (this, arguments, function (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = Oe (this, e);t.insertBefore (e, t.firstChild)}})}, before: function () {return Ie (this, arguments, function (e) {this.parentNode && this.parentNode.insertBefore (e, this)})}, après : function () {return Ie (this, arguments, function (e) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, vide: function () {pour (var e, t = 0; null! = (e = this [t]); t ++) 1 === e.nodeType && (k.cleanData (ve (e,! 1)), e.textContent = ""); renvoie this}, clone: ​​function (e, t) {return e = null! = e && e, t = null == t = e: t, this.map (function () {return k.clone (this, e, t)})}, html: function (e) {return _ (this, fonction (e) {var t = this [0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t. nodeType) retourne t.innerHTML; if ("chaîne" == typede e &&! qe.test (e) &&! ge [(de.exec (e) || ["", ""]) [1] .toLowerCase ( )]) {e = k.htmlPrefilter (e); try {for (; n <r;n ++) 1 === (t = this [n] || {}). nodeType && (k.cleanData (ve (t,! 1)), t.innerHTML = e); t = 0} catch (e) { }} t && this.empty (). append (e)}, null, e, arguments.length)}, replaceWith: function () {var n = []; retourne Ie (ceci, arguments, fonction (e) {var t = this.parentNode; k.inArray (this, n) <0 && (k.cleanData (ve (this)), t && t.replaceChild (e, this))}, n)}}), k.each ({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith"}, fonction (e, a) {k.fn [e] = fonction (e) {pour ( var t, n = [], r = k (e), i = r.longueur-1, o = 0; o <= i; o ++) t = o === i? ceci: ceci.clone (! 0 ), k (r [o]) [a] (t), u.apply (n, t.get ()); renvoie this.pushStack (n)}}); var $ e = new RegExp ("^ ( "+ te +") (?! px) [az%] + $ "," i "), Fe = fonction (e) {var t = e.ownerDocument.defaultView; renvoyer t && t.opener || (t = C) , t.getComputedStyle (e)}, Be = new RegExp (re.join ("|"), "i"); fonction _e (e, t, n) {varr, i, o, a, s = e.style; return (n = n || Fe (e)) && (""! == (a = n.getPropertyValue (t) || n [t]) || oe (e) || (a = k.style ( e, t)),! y.pixelBoxStyles () && $ e.test (a) && Be.test (t) && (r = largeur s, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0! == a? a + "": a} fonction ze (e, t) {return {get: function () {if (! e ()) return (this.get = t) .apply (this, arguments); supprime this.get}}}! function () { fonction e () {si (u) {s.style.cssText = "position: absolue; gauche: -11111px; largeur: 60px; marge supérieure: 1px; remplissage: 0; bordure: 0", u.style.cssTexte = "position: relative; display: block; size-box: border-box; débordement: scroll; margin: auto; border: 1px; padding: 1px; largeur: 60%; haut: 1%", ie.appendChild (s ) .appendChild (u);var e = C.getComputedStyle (rCase (); retourne n || (i = gt [o], gt [o] = r, r = nul! = a (e, t, n)? o: nul, gt [o] = i), r }}); var vt = / ^ (?: input | select | textarea | button) $ / i, yt = / ^ (?: une | zone) $ / i; fonction mt (e) {return (e.match (R) || []). Join ("")} fonction xt (e) {return e.getAttribute && e.getAttribute ("classe") || ""} fonction bt (e) {return Array.isArray (e) ? e: "chaîne" == typede e && e.match (R) || []} k.fn.extend ({prop: fonction (e, t) {return _ (this, k.prop, e, t, 1 <arguments.length)}, removeProp: function (e) {retourne this.each (function () {delete this [k.propFix [e] || e]})}}), k.extend ({prop: fonction (e, t, n) {var r, i, o = e.nodeType; if (3! == o && 8! == o && 2! == o) retourne 1 === o && k.isXMLDoc (e) || (t = k.propFix [t] || t, i = k.propHooks [t]), vide 0! == n? i && "set" dans i && void 0! == (r = i.set (e, n, t ))? r: e [t] = n: i && "get" dans i && null! == (r = i.get (e,t))? r: e [t]}, propHooks: {tabIndex: {get: function (e) {var t = k.find.attr (e, "tabindex"); retourne t? parseInt (t, 10) : vt.test (e.nodeName) || yt.test (e.nodeName) && e.href? 0: -1}}}, propFix: {"pour": "htmlFor", "class": "className"} }), y.optSelected || (k.propHooks.selected = {get: function (e) {var t = e.parentNode; renvoyer t && t.parentNode && t.parentNode.selectedIndex, null}, défini: function (e) {var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)}}), k.each (["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellSpacing", "cellPadding", " rowSpan "," colSpan "," useMap "," frameBorder "," contentEditable "], function () {k.propFix [this.toLowerCase ()] = this}), k.fn.extend ({addClass: function ( t) {var e, n, r, i, o, a,s, u = 0; if (m (t)) renvoie this.each (fonction (e) {k (this) .addClass (t.call (this, e, xt (this)))}); if (( e = bt (t)). longueur) tandis que (n = ce [u ++]) si (i = xt (n), r = 1 === n.nodeType && "" + mt (i) + "") {a = 0; while (o = e [a ++]) r.indexOf ("" + o + "") <0 && (r + = o + ""); i! == (s = mt (r)) && n.setAttribute (" class ", s)} renvoie ceci}, removeClass: fonction (t) {var e, n, r, i, o, a, s, u = 0; si (m (t)) renvoie cet.each (fonction ( e) {k (this) .removeClass (t.call (this, e, xt (this)))}); if (! arguments.length) renvoie this.attr ("classe", ""); if (( e = bt (t)). longueur) tandis que (n = ce [u ++]) si (i = xt (n), r = 1 === n.nodeType && "" + mt (i) + "") {a = 0; while (o = e [a ++]) tandis que (-1 <r.indexOf ("" + o + "")) r = r.remplace ("" + o + "", ""); i! == (s = mt (r)) && n.setAttribute ("classe",s)} return this}, toggleClass: function (i, t) {var o = typede i, a = "chaîne" === o || Array.isArray (i); retourner "booléen" == type de t && a? t ? this.addClass (i): this.removeClass (i): m (i)? this.each (fonction (e) {k (this) .toggleClass (i.call (this, e, xt (this), t ), t)}): this.each (function () {var e, t, n, r; si (a) {t = 0, n = k (ceci), r = bt (i); tandis que (e = r [t ++]) n.hasClass (e)? n.removeClass (e): n.addClass (e)} sinon vide 0! == i && "booléen"! == o || ((e = xt (this )) && Q.set (this, "__ className __", e), this.setAttribute && this.setAttribute ("class", e ||! 1 === i? "": Q.get (this, "__ className __") || ""))})}, hasClass: fonction (e) {var t, n, r = 0; t = "" + e + ""; tandis que (n = ce [r ++]) if (1 === n. nodeType && - 1 <("" + mt (xt (n)) + ") .indexOf (t)) return! 0; return! 1}}); var wt = / \ r / g; k.fn.extend ({val:function (n) {var r, e, i, t = this [0]; retourne arguments.length? (i = m (n), this.each (fonction (e) {var t; 1 === this. nodeType && (null == (t = i? n.call (this, e, k (this) .val ()): n)? t = "": "nombre" == type de t? t + = "": Tableau .isArray (t) && (t = k.map (t, fonction (e) {retour null == e? "": e + ""})), (r = k.valHooks [this.type] || k .valHooks [this.nodeName.toLowerCase ()] && "set" dans r && void 0! == r.set (this, t, "valeur") || (this.value = t))})): t? (r = k.valHooks [t.type] || k.valHooks [t.nodeName.toLowerCase ()]) && "get" in r && void 0! == (e = r.get (t, "valeur")) ? e: "string" == typeof (e = t.value)? e.replace (wt, ""): null == e? "": e: void 0}}), k.extend ({valHooks: {option: {get: fonction (e) {var t = k.find.attr (e, "valeur"); renvoie null! = t? t: mt (k.text (e))}}, sélectionnez: { obtenir:fonction (e) {var t, n, r, i = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a? null: [], u = a ? o + 1: i.length; pour (r = o <0? u: a? o: 0; r <u; r ++) if (((n = i [r]).. sélectionné || r === o) &&! n.disabled && (! n.parentNode.disabled ||! A (n.parentNode, "optgroup"))) {if (t = k (n) .val (), a) retourne t; s. push (t)} retourne s}, set: fonction (e, t) {var n, r, i = e.options, o = k.makeArray (t), a = i.longueur; while (a--) ((r = i [a]). sélectionné = -1 <k.inArray (k.valHooks.option.get (r), o)) && (n =! 0); retourne n || (e.selectedIndex = -1), o}}}}), k.each (["radio", "case à cocher"], function () {k.valHooks [this] = {set: function (e, t) {if (Array. isArray (t)) return e.checked = -1 <k.inArray (k (e) .val (), t)}}, y.checkOn || (k.valHooks [this] .get = fonction (e) {return null === e.getAttribute ("valeur")? "sur": e.valeur})}), y.focusin = "onfocusin" en C; var Tt = / ^ (?:focusinfocus | focusoutblur) $ /, Ct = fonction (e) {e.stopPropagation ()}; k.extend (k.event, {trigger: fonction (e, t, n, r) {var i, o, a, s, u, l, c, f, p = [n || E], d = v.call (e, "type")? e.type: e, h = v.call (e, "espace de nom") ? e.namespace.split ("."): []; si (o = f = a = n = n || E, 3! == n.nodeType && 8! == n.nodeType &&! Tt.test (d + k.event.triggered) && (- 1 <d.indexOf (".") && (d = (h = d.split (".")). shift (), h.sort ()), u = d .indexOf (":") <0 && "on" + d, (e = e [k.expando]? e: new k.Event (d, "object" == typeof e && e)). isTrigger = r? 2: 3, e.namespace = h.join ("."), E.rnamespace = e.namespace? New RegExp ("(^ | \\.)" + H.join ("\\. (?:. * \ \. |) ") +" (\\. | $) "): null, e.result = nul 0, e.target || (e.target = n), t = null == t? [e] : k.makeArray (t, [e]), c = k.event.special [d] || {}, r ||! c.trigger ||! 1! == c.trigger.apply (n, t))) {if (! r &&! c.noBubble &&! x (n)) {pour (s = c.delegateType || d, Tt.test (s + d) || (o = o.parentNode); o; o = o.parentNode) p.push (o), a = o; a === (n.ownerDocument || E) && p.push (a.defaultView || a.parentWindow || C)} i = 0; tandis que ((o = p [i ++]) &&! E.isPropagationStopped ()) f = o, e.type = 1 <i? S: c.bindType || d, (l = ( Q.get (o, "events") || {}) [e.type] && Q.get (o, "handle")) && l.apply (o, t), (l = u && o [u]) && l. apply && G (o) && (e.result = l.apply (o, t),! 1 === e.result && e.preventDefault ()); renvoyer e.type = d, r || e.isDefaultPrevented () || c._default &&! 1! == c._default.apply (p.pop (), t) ||! G (n) || u && m (n [d]) &&! x (n) && ((a = n [u]) && (n [u] = null), k.event.triggered = d, e.isPropagationStopped () && f.addEventListener (d, Ct), n [d] (), e.isPropagationStopped () && f.removeEventListener (d, Ct), k.event.triggered = void 0, a && (n [u] = a)), e.result}}, simuler: fonction (e, t, n) {var r = k.extend (new k.Event, n, {type: e, isSimulated:! 0}); k.event.trigger (r, null, t)}}), k.fn.extend ({trigger: function (e, t ) {retour this.each (function () {k.event.trigger (e, t, this)})}, triggerHandler: fonction (e, t) {var n = this [0]; si (n) retourne k .event.trigger (e, t, n,! 0)}}), y.focusin || k.each ({focus: "focusin", flou: "focusout"}, fonction (n, r) {var i = function (e) {k.event.simulate (r, e.target, k.event.fix (e))}; k.event.special [r] = {setup: function () {var e = this. ownerDocument || this, t = Q.access (e, r); t || e.addEventListener (n, i,! 0), Q.access (e, r, (t || 0) +1)}, démontage: function () {var e = this.ownerDocument || this, t = Q.access (e, r) -1; t? Q.access (e, r, t) :( e.removeEventListener (n, i ,! 0), Q.remove (e, r))}}}); var Et = EmplacementC, kt = Date.now (), St = / \? /; K.parseXML = fonction (e) { var t;if (! e || "string"! = typeof e) renvoie null; essayez {t = (nouveau C.DOMParser) .parseFromString (e, "text / xml")} catch (e) {t = void 0} return t &&! t.getElementsByTagName ("analyseur"). length || k.error ("XML invalide:" + e), t}; var Nt = / \ [\] $ /, At = / \ r? \ n / g, Dt = / ^ (?: soumettre | bouton | image | réinitialiser | fichier) $ / i, jt = / ^ (?: entrée | sélectionner | textarea | keygen) / i; fonction qt (n, e, r, i) {var t; if (Array.isArray (e)) k.each (e, fonction (e, t) {r || Nt.test (n)? i (n, t): qt (n + "[ "+ (" objet "== typede t && null! = t? e:" ") +"] ", t, r, i)}); sinon si (r ||" objet "! == w (e)) i (n, e); sinon pour (t dans e) qt (n + "[" + t + "]", e [t], r, i)} k.param = fonction (e, t) {var n, r = [], i = fonction (e, t) {var n = m (t)? t (): t; r [longueur.ligne] = codecURIComponent (e) + "=" + codecURIComponent (null == n ? "": n)}; if (null == e) renvoie ""; if (Array.isArray (e) || e.jquery &&! k.isPlainObject (e)) k.each (e, function () {i (this.name, this.name)}); sinon pour (n dans e) qt (n , e [n], t, i); return r.join ("&")}, k.fn.extend ({serialize: function () {return k.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var e = k.prop (this, "elements"); retour e? k.makeArray (e): this}). filter (function () {var e = this.type; return this.name &&! k (this) .is (": disabled") && jt.test (this.nodeName) &&! Dt.test (e) && (this.checked ||! pe.test (e ))}). map (fonction (e, t) {var n = k (ceci) .val (); retourne null == n? null: Array.isArray (n)? k.map (n, fonction (e ) {return {nom: t.nom, valeur: e.replace (à, "\ r \ n")}}): {nom: t.nom, valeur: n.replace (à, "\ r \ n" )}}). get ()}}); var Lt = /% 20 / g, Ht = / #. * $ /, Ot = / ([? &]) _ = [^ &] * /, Pt = / ^ (. *?): [\ t] * ([^ \ r \ n] *) $ / gm, Rt = / ^ (?:GET | HEAD) $ /, Mt = / ^ \ / \ //, It = {}, Wt = {}, $ t = "* /". Concat ("*"), Ft = E.createElement ("a "); fonction Bt (o) {fonction de retour (e, t) {" chaîne "! = typede e && (t = e, e =" * "); var n, r = 0, i = e.toLowerCase () .match (R) || []; if (m (t)) tandis que (n = i [r ++]) "+" === n [0]? (n = n.slice (1) || "* ", (o [n] = o [n] || []). unshift (t)) :( o [n] = o [n] || []). push (t)}} fonction _t (t , i, o, a) {var s = {}, u = t === Wt; fonction l (e) {var r; retour s [e] =! 0, k.each (t [e] || [], fonction (e, t) {var n = t (i, o, a); retourne "chaîne"! = typede n || u || s [n]? u?! (r = n): void 0: (i.dataTypes.unshift (n), l (n),! 1)}), r} retourne l (i.dataTypes [0]) ||! S ["*"] && l ("*") } fonction zt (e, t) {var n, r, i = k.ajaxSettings.flatOptions || {}; pour (n dans t) vide 0! == t [n] && ((i [n]? e : r || (r = {})) [n] = t [n]); renvoie r && k.extend (! 0, e, r), e} Ft.href = Et.href, k.extend ({active : 0,lastModified: {}, etag: {}, ajaxSettings: {url: Et.href, tapez: "GET", isLocal: / ^ (?: à propos de | app | app-storage |. + extension | fichier | res | widget ): $ /. test (protocole standard), global:! 0, processData:! 0, async:! 0, contentType: "application / x-www-form-urlencoded; charset = UTF-8", accepte: { "*": $ t, text: "text / plain", html: "text / html", xml: "application / xml, text / xml", json: "application / json, text / javascript"}, contenu: {xml: / \ bxml \ b /, html: / \ bhtml /, json: / \ bjson \ b /}, responseFields: {xml: "responseXML", texte: "responseText", json: "responseJSON"}, convertisseurs : {"* text": String, "text html":! 0, "text json": JSON.parse, "text xml": k.parseXML}, flatOptions: {url:! 0, contexte:! 0}} , ajaxSetup: fonction (e, t) {retourne t? zt (zt (e, k.ajaxSettings), t): zt (k.ajaxSettings, e)}, ajaxPrefilter:Bt (It), ajaxTransport: Bt (Wt), ajax: fonction (e, t) {"objet" == typede e && (t = e, e = vide 0), t = t || {}; var c, f, p, n, d, r, h, g, i, o, v = k.ajaxSetup ({}, t), y = v.context || v, m = v.context && (y.nodeType || y.jquery)? k (y): k.event, x = k.Deferred (), b = k.Callbacks ("une fois en mémoire"), w = v.statusCode || {}, a = {}, s = {}, u = "annulé", T = {readyState: 0, getResponseHeader: fonction (e) {var t; si (h) {if (! n) {n = {}; tant que (t = Pt.exec (p)) n [t [1] .toLowerCase () + ""] = (n [t [1] .toLowerCase () + ""] || []). concat (t [2])} t = n [e.toLowerCase () + ""]} renvoie null == t? null: t.join (",")}, getAllResponseHeaders: function () {retourne h? p: null}, setRequestHeader: function (e, t) {return null == h && (e = s [e.toLowerCase ()] = s [e.toLowerCase ()] || e, a [e] = t), this}, overrideMimeType: function (e) { return null == h && (v.mimeType = e), this}, statusCode: function (e) {var t;si (e) si (h) T.a toujours (e [T.status]); sinon pour (t dans e) w [t] = [w [t], e [t]]; retourne ceci}, annule: fonction (e) {var t = e || u; retourne c && c.abort (t), l (0, t), ceci}}; if (x.promise (T), v.url = ((e || v.url || Et.href) + ""). replace (Mt, Et.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*"). toLowerCase (). match (R) || [""], null == v.crossDomain) {r = E.createElement ("a"); try {r.href = v.url, r.href = r.href, v.crossDomain = Ft.protocol + "//" + Ft.host! = r.protocol + "//" + r.host} catch (e) {v.crossDomain =! 0}} if (v.data && v.processData && "chaîne"! = typeof v.data && (v.data = k.param (v.data, v.traditional)), _ t (It, v, t, T), h) retourne T; pour (i dans (g = k.event && v.global) && 0 == k.active ++ && k.event.trigger ("ajaxStart"), v.type = v.type. toUpperCase (), v.hasContent =! Rt.test (v.type), f = v.url.replace (Ht, ""), v.hasContent? v.data && v.processData && 0 === (v.contentType || ""). indexOf ( "application / x-www-form-urlencoded") && (v.data = v.data.replace (Lt, "+")) :( o = v.url.slice (f.length), v.data && ( v.processData || "string" == typede v.data) && (f + = (St.test (f)? "&": "?") + v.data, supprimez v.data),! 1 == = v.cache && (f = f.replace (Ot, "$ 1"), o = (St.test (f)? "&": "?") + "_ =" + kt +++ o), v .url = f + o), v.ifModified && (k.lastModified [f] && T.setRequestHeader ("If-Modified-Since", k.lastModified [f]), k.etag [f] && T.setRequestHeader ("If -None-Match ", k.etag [f])), (v.data && v.hasContent &&! 1! == v.contentType || t.contentType) && T.setRequestHeader ("Content-Type", v.contentType), T.setRequestHeader ("Accepter", v.dataTypes [0] && v.accepts [v.dataTypes [0]]? v.accepts [v.dataTypes [0]] + ("*"! == v.dataTypes [0]? "," + $ t + "; q = 0.01": "): v.accepts [" * "]), v.headers) T.setRequestHeader ( i, v.headers [i]); if (v.beforeSend && (! 1 === v.beforeSend.call (y, T, v) || h)) renvoie T.abort (); if (u = " abandonner ", b.add (v.complete), T.done (v.success), T. échouer (v.error), c = _t (Wt, v, t, T)) {if (T.readyState = 1, g && m.trigger ("ajaxSend", [T, v]), h) renvoie T; v.async && 0 <v.timeout && (d = C.setTimeout (function () {T.abort ("timeout")},}, v.timeout)); essayez {h =! 1, c.send (a, l)} attrapez (e) {si (h) lancez e; l (-1, e)}} sinon l (-1, " Pas de transport "); fonction l (e, t, n, r) {var i, o, a, s, u, l = t; h || (h =! 0, d && C.clearTimeout (d), c = vide 0,p = r || "", T.readyState = 0 <e? 4: 0, i = 200 <= e && e <300 || 304 === e, n && (s = fonction (e, t, n) {var r, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u [0]) u.shift (), void 0 === r && (r = e. mimeType || t.getResponseHeader ("Content-Type")); if (r) pour (i dans s) if (s [i] && s [i] .test (r)) {u.unshift (i); pause } if (u [0] dans n) o = u [0]; sinon {pour (i dans n) {if (! u [0] || e.convertisseurs [i + "" + u [0]]) { o = i; pause} a || (a = i)} o = o || a} if (o) renvoie o! == u [0] && u.unshift (o), n [o]} (v, T, n)), s = fonction (e, t, n, r) {var i, o, a, s, u, l = {}, c = e.dataTypes.slice (); if (c [1 ]) for (a in e.converters) l [a.toLowerCase ()] = e.converters [a]; o = c.shift (); tant que (o) if (e.responseFields [o] && (n [ e.responseFields [o]] = t),! u && r && e.dataFilter && (t = e.dataFilter (t, e.dataType)), u = o, o = c.shift ()) if ("* *" === o) o = u; sinon si ("*"! == u && u!== o) {si (! (a = l [u + "" + o] || l ["*" + o])) pour (i dans l) si ((s = i.split ("")) [1] === o && (a = l [u + "" + s [0]] || l ["*" + s [0]])) {! 0 === a? A = l [i] :! 0! == l [i] && (o = s [0], c.unshift (s [1])); pause} if (! 0! == a) if (a && e ["jette"]) t = a (t); sinon essayez {t = a (t)} catch (e) {return {état: "analyseur", erreur: a? ​​e: "Aucune conversion de" + u + "en" + o}} } return {état: "succès", données: t}} (v, s, T, i), i? (v.ifModifié && ((u = T.getResponseHeader ("Dernier modifié")) && (k.lastModifié [f] = u), (u = T.getResponseHeader ("etag")) && (k.etag [f] = u)), 204 === e || "HEAD" === v.type? l = "nocontent": 304 === e? l = "non modifié" :( l = s.state, o = s.data, i =! (a = s.error))) :( a = l,! e && l || (l = "erreur", e <0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i? x.resolveWith (y, [o, l, T]): x.rejectWith (y, [T, l, a]), T.statusCode (w) , w = void 0, g && m.trigger (i? "ajaxSuccess": "ajaxError", [T, v, i? o: a]), b.fireWith (y, [T, l]), g && (m. trigger ("ajaxComplete", [T, v]), - k.active || k.event.trigger ("ajaxStop")))} retourne T}, getJSON: fonction (e, t, n) {retourne k .get (e, t, n, "json")}, getScript: fonction (e, t) {retourne k.get (e, vide 0, t, "script")}}), k.each ([" get "," post "], fonction (e, i) {k [i] = fonction (e, t, n, r) {retour m (t) && (r = r || n, n = t, t = void 0), k.ajax (k.extend ({url: e, type: i, dataType: r, données: t, succès: n}, k.isPlainObject (e) && e))}}, k. _evalUrl = function (e, t) {return k.ajax ({url: e, type: "GET", dataType: "script", cache:! 0, async:! 1, global:! 1, convertisseurs: {" script de texte ": function () {}}, dataFilter:fonction (e) {k.globalEval (e, t)}})}, k.fn.extend ({wrapAll: fonction (e) {var t; retourne ceci [0] && (m (e) && (e = e.call (this [0])), t = k (e, this [0] .ownerDocument) .eq (0) .clone (! 0), this [0] .parentNode && t.insertBefore (this [0]) , t.map (function () {var e = this; while (e.firstElementChild) e = e.firstElementChild; return e}). append (this)), this}, wrapInner: function (n) {return m ( n)? this.each (fonction (e) {k (this) .wrapInner (n.call (this, e))}): this.each (fonction () {var e = k (this), t = e .contents (); t.length? t.wrapAll (n): e.append (n)})}, wrap: function (t) {var n = m (t); renvoie this.each (fonction (e) {k (this) .wrapAll (n? t.call (this, e): t)})}, unwrap: function (e) {retourne ce.parent (e) .not ("corps"). each (fonction () {k (this) .replaceWith (this.childNodes)}), this}}), k.expr.pseudos.hidden = fonction (e) {return! k.expr.pseudos.visible (e)}, k .expr.pseudos.visible = function (e) {return !! (e.offsetWidth || e.offsetHeight || e.getClientRects (). length)}, k.ajaxSettings.xhr = function () {try {retourne une nouvelle valeur C.XMLHttpRequest} catch (e) {}}; var Ut = {0: 200,1223: 204}, Xt = k.ajaxSettings.xhr (); y.cors = !! Xt && "withCredentials" dans Xt, y.ajax = Xt = !! Xt, k.ajaxTransport (fonction (i) {var o, a; if (y.cors || Xt &&! i.crossDomain) renvoie {send: function (e, t) {var n, r = i.xhr (); if (r.open (i.type, i .url, i.async, i.username, i.password), i.xhrFields) pour (n dans i.xhrFields) r [n] = i.xhrFields [n]; pour (n dans i.mimeType && r.overrideMimeType && r. overrideMimeType (i.mimeType), i.crossDomain || e ["X-Requested-With"] || (e ["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader (n, e [n]); o = fonction (e) {retour fonction () {o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abandonner" == = e? r.abort (): "erreur "=== e?" numéro "! = typed'état de statut? t (0," erreur "): t (état.r, étatTexte): t (Ut [état.status] || état.r , r.statusText, "text"! == (r.responseType || "text") || "chaîne"! = typede r.responseText? {binary: r.response}: {text: r.responseText}, r .getAllResponseHeaders ()))}}, r.onload = o (), a = r.onerror = r.ontimeout = o ("erreur"), vide 0! == r.onabort? r.onabort = a: r .onreadystatechange = function () {4 === r.readyState && C.setTimeout (function () {o && a ()})}, o = o ("abort"); try {r.send (i.hasContent && i.data || null)} catch (e) {if (o) jette e}}, annule: function () {o && o ()}}}), k.ajaxPrefilter (function (e) {e.crossDomain && (e.contents.script = ! 1)}), k.ajaxSetup ({accepte: {script: "texte / javascript, application / javascript, application / ecmascript, application / x-ecmascript"}, contenu: {script: / \ b (?:java | ecma) script \ b /}, convertisseurs: {"script de texte": fonction (e) {retourne k.globalEval (e), e}}}), k.ajaxPrefilter ("script", fonction (e) { void 0 === e.cache && (e.cache =! 1), e.crossDomain && (e.type = "GET")}), k.ajaxTransport ("script", fonction (n) {var r, i; if (n.crossDomain || n.scriptAttrs) renvoie {send: function (e, t) {r = k ("<script>"). attr (n.scriptAttrs || {}). prop ({jeu de caractères: n .scriptCharset, src: n.url}). on ("erreur de chargement", i = fonction (e) {r.remove (), i = null, e && t ("erreur" === e.type? 404: 200 , e.type)}), E.head.appendChild (r [0])}, annulez: function () {i && i ()}}); var Vt, Gt = [], Yt = / (=) \ ? (? = & | $) | \? \? /; k.ajaxSetup ({jsonp: "callback", jsonpCallback: function () {var e = Gt.pop () || k.expando + "_" + kt ++ ; retourne ce [e] =! 0, e}}), k.ajaxPrefilter ("json jsonp", fonction (e, t, n) {var r, i,o, a =! 1! == e.jsonp && (Yt.test (e.url)? "url": "chaîne" == typede e.data && 0 === (e.contentType || ""). indexOf ( "application / x-www-form-urlencoded") && Yt.test (e.data) && "données"); if (a || "jsonp" === e.dataTypes [0]) renvoie r = e.jsonpCallback = m (e.jsonpCallback)? e.jsonpCallback (): e.jsonpCallback, un? e [a] = e [a] .remplace (Yt, "$ 1" + r):! 1! == e.jsonp && ( e.url + = (St.test (e.url)? "&": "?") + e.jsonp + "=" + r), e.converters ["script json"] = function () {retour o | | k.error (r + "n'a pas été appelé"), o [0]}, e.dataTypes [0] = "json", i = C [r], C [r] = fonction () {o = arguments} toujours (function () {void 0 === i? k (C) .removeProp (r): C [r] = i, e [r] && (e.jsonpCallback = t.jsonpCallback, Gt.push (r)), o && m (i) && i (o [0]), o = i = vide 0}), "script"}), y.createHTMLDocument = ((Vt = E.implementation.createHTMLDocument (""). body)) .innerHTML = "<form> </ form> <form> </ form>", 2 === Vt.childNodes .length), k.parseHTML = fonction (e, t, n) {retourne "chaîne"! = typede e? [] :( "booléen" == typede t && (n = t, t =! 1), t | | (y.createHTMLDocument? ((r = (t = E.implementation.createHTMLDocument ("")). CreateElement ("base")). href = E.location.href, t.head.appendChild (r)): t = E), o =! n && [], (i = D.exec (e))? [t.createElement (i [1])] :( i = we ([e], t, o), o && o .length && k (o) .remove (), k.merge ([], i.childNodes))); varr, i, o}, k.fn.load = fonction (e, t, n) {var r, i, o, a = ceci, s = e.indexOf (""); return-1 <s && (r = mt (e.slice (s)), e = e.slice (0, s)), m ( t)? (n = t, t = vide 0): t && "objet" == typede t && (i = "POST"), 0 <a.length && k.ajax ({url: e, tapez: i || "GET", dataType: "html", data: t}). done (fonction (e) {o = arguments, a.html (r? k ("<div > "). append (k.parseHTML (e)). find (r): e)}). always (n && fonction (e, t) {a.each (fonction () {n.apply (this, o || [e.responseText, t, e])}}}, this}, k.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], fonction ( e, t) {k.fn [t] = fonction (e) {retourne ceci.on (t, e)}}), k.expr.pseudos.animated = fonction (t) {retourne k.grep (k. minuteries, fonction (e) {retour t === e.elem}). longueur}, k.offset = {setOffset: fonction (e, t, n) {varr, i, o, a, s, u, l = k.css (e, "position"), c = k (e), f = {}; "statique" === l && (e.style.position = "relatif"), s = c.offset ( ), o = k.css (e, "haut"), u = k.css (e, "gauche"), ("absolu" === l || "fixé" === l) && -1 <(o + u) .indexOf ("auto")? (A = (r = c.position ()). Top, i = r.left) :( a = parseFloat (o) || 0, i = parseFloat (u) || 0), m (t) && (t = t.call (e, n, k.extend ({}, s))), null! = t.top && (f.top = t.top-s.top + a), null! = t.left && (f.left = t.left-s.left + i), "utiliser" dans t? t.using.call (e, f): c.css (f)}}, k.fn.extend ({offset: function (t) {if (arguments.length)) renvoie vide 0 === t? ceci: ceci.each (fonction (e) {k. offset.setOffset (this, t, e)}; var e, n, r = this [0]; return r? r.getClientRects (). length? (e = r.getBoundingClientRect (), n = r.ownerDocument .defaultView, {top: e.top + n.pageYOffset, gauche: e.left + n.pageXOffset}): {top: 0, gauche: 0}: void 0}, position: function () {if (this [ 0]) {var e, t, n, r = ce [0], i = {en haut: 0, à gauche: 0}; if ("fixed" === k.css (r, "position")) t = r.getBoundingClientRect (); else {t = this.offset (), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && "statique" === k.css (e, "position")) e = e.parentNode; e && e! == r && 1 == = e.nodeType && ((i = k (e) .offset ()). top + = k.css (e, "borderTopWidth",! 0), i.left + = k.css (e, "borderLeftWidth",! 0 ))} return {top: t.top-i.top-k.css (r, "marginTop",! 0), à gauche: t.left-i.left-k.css (r, "marginLeft",! 0)}}}, offsetParent: function () {return this.map (function () {var e = this.offsetParent; while (e && "static" === k.css (e, "position")) e = e.offsetParent; renvoie e || ie})}}), k.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, fonction (t, i) {var o = "pageYOffset" === i ; k.fn [t] = fonction (e) {return _ (ceci, fonction (e, t, n) {var r; si (x (e)? r = e: 9 === e.nodeType && (r = e.defaultView), vide 0 === n) retourne r? r [i]: e [t]; r? r.scrollTo (o? r.pageXOffset: n, o? n: r.pageYOffset): e [t] = n}, t, e, arguments.length)}}), k.each (["haut", "gauche"], fonction (e , n) {k.cssHooks [n] = ze (y.pixelPosition, fonction (e, t) {si (t) renvoie t = _e (e, n), $ e.test (t)? k (e) .position () [n] + "px": t})}), k.each ({hauteur: "hauteur", largeur: "largeur"}, fonction (a, s) {k.each ({padding: "inner" + a, contenu: s, "": "outer" + a}, fonction (r, o) {k.fn [o] = fonction (e, t) {var n = arguments.length && (r | | "booléen"! = typede e), i = r || (! 0 === e ||! 0 === t? "marge": "bordure"); retourne _ (cette fonction (e, t , n) {var r; retourne x (e)? 0 === o.indexOf ("outer")? e ["inner" + a]: e.document.documentElement ["client" + a]: 9 = == e.nodeType? (r = e.documentElement, Math.max (e.body ["scroll" + a], r ["scroll" + a], e.body ["offset" + a], r [ "décalage"+ a], r ["client" + a])): vide 0 === n? k.css (e, t, i): style k (e, t, n, i)}, s, n ? e: void 0, n)}}}}, k.each ("blur focus focusin focusout redimensionner clic de défilement cliquer dblclick mousedown mousemove mouseover déplacer la souris mouseenter déplacer la souris changer sélectionner envoyer touche à clé appuyer sur keyup contextmenu". " (e, n) {k.fn [n] = fonction (e, t) {retour 0 <arguments.length? this.on (n, null, e, t): this.trigger (n)}}), k.fn.extend ({survol: fonction (e, t) {retour this.mouseenter (e) .mouseleave (t || e)}}), k.fn.extend ({bind: fonction (e, t, n) {retourne this.on (e, null, t, n)}, unbind: fonction (e, t) {retour this.off (e, null, t)}, délégué: fonction (e, t, n, r) {retourne this.on (t, e, n, r)}, non délégué: fonction (e, t, n) {retourne 1 === arguments.length? this.off (e, "**"): this.off (t, e || "**", n)}}), k.proxy = fonction (e, t) {var n, r, i; if ("chaîne" == typede t && (n = e [t],t = e, e = n), m (e)) renvoie r = s.call (arguments, 2), (i = fonction () {retourne e.apply (t || this, r.concat (s.call (arguments))}}. guid = e.guid = e.guid || k.guid ++, i}, k.holdReady = fonction (e) {e? k.readyWait ++: k.ready (! 0)}, k.isArray = Array.isArray, k.parseJSON = JSON.parse, k.nodeName = A, k.isFunction = m, k.isWindow = x, k.camelCase = V, k.type = w, k.now = Date, maintenant, k.isNumeric = fonction (e) {var t = k.type (e); return ("nombre" === t || "chaîne" === t) &&! IsNaN (e-parseFloat ( e))}, "function" == typeof définir && define.amd && define ("jquery", [], fonction () {return k}); var Qt = C.jQuery, Jt = C. $; return k.noConflict = fonction (e) {return C. $ === k && (C. $ = Jt), e && CjQuery === k && (CjQuery = Qt), k}, e || (CjQuery = C. $ = k), k});guid || k.guid ++, i}, k.holdReady = fonction (e) {e? k.readyWait ++: k.ready (! 0)}, k.isArray = Array.isArray, k.parseJSON = JSON.parse, k.nodeName = A, k.isFunction = m, k.isWindow = x, k.camelCase = V, k.type = w, k.now = Date.now, k.isNumeric = fonction (e) {var t = k.type (e); return ("nombre" === t || "chaîne" === t) &&! isNaN (e-parseFloat (e))}, "fonction" == typede définir && define.amd && define (" jquery ", [], function () {return k}); var Qt = C ++, Jt = C. $; return k.noConflict = function (e) {return C. $ === k && (C. $ = Jt), e && C_Query === k && (CjQuery = Qt), k}, e || (CjQuery = C. $ = K), k});guid || k.guid ++, i}, k.holdReady = fonction (e) {e? k.readyWait ++: k.ready (! 0)}, k.isArray = Array.isArray, k.parseJSON = JSON.parse, k.nodeName = A, k.isFunction = m, k.isWindow = x, k.camelCase = V, k.type = w, k.now = Date.now, k.isNumeric = fonction (e) {var t = k.type (e); return ("nombre" === t || "chaîne" === t) &&! isNaN (e-parseFloat (e))}, "fonction" == typede définir && define.amd && define (" jquery ", [], function () {return k}); var Qt = C ++, Jt = C. $; return k.noConflict = function (e) {return C. $ === k && (C. $ = Jt), e && C_Query === k && (CjQuery = Qt), k}, e || (CjQuery = C. $ = K), k});=== t || "string" === t) &&! isNaN (e-parseFloat (e))}, "fonction" == type de définir && define.amd && définir ("jquery", [], fonction () {retour k }); var Qt = C.jQuery, Jt = C. $; retourne k.noConflict = fonction (e) {retourne C. $ === k && (C. $ = Jt), e && C.jQuery === k && ( C.jQuery = Qt), k}, e || (C.jQuery = C. $ = K), k});=== t || "string" === t) &&! isNaN (e-parseFloat (e))}, "fonction" == type de définir && define.amd && définir ("jquery", [], fonction () {retour k }); var Qt = C.jQuery, Jt = C. $; retourne k.noConflict = fonction (e) {retourne C. $ === k && (C. $ = Jt), e && C.jQuery === k && ( C.jQuery = Qt), k}, e || (C.jQuery = C. $ = K), k});